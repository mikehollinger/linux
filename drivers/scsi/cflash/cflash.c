
/*
* Copyright 2015 IBM Corp.
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version
* 2 of the License, or (at your option) any later version.
*/
#include <linux/pci.h>
#include <linux/module.h>
#include <linux/module.h>
#include <linux/semaphore.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/libata.h>
#include <linux/reboot.h>

#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_tcq.h>
#include <scsi/scsi_eh.h>
#include <scsi/scsi_cmnd.h>

static unsigned int cflash_debug = 0;

#include "cflash.h"

MODULE_DESCRIPTION("IBM CAPI Flash Adapter Driver");
MODULE_AUTHOR("Manoj Kumar <kumarmn@us.ibm.com>");
MODULE_AUTHOR("Paul Prahl <prahl@us.ibm.com>");
MODULE_AUTHOR("Matthew Ochs <mrochs@us.ibm.com>");
MODULE_LICENSE("GPL");


/**
 * cflash_ioa_info - Get information about the card/driver
 * @scsi_host:       scsi host struct
 *
 * Return value:
 *      pointer to buffer with description string
 **/
static const char *cflash_ioa_info(struct Scsi_Host *host)
{
        static char buffer[512];
        unsigned long lock_flags = 0;

        spin_lock_irqsave(host->host_lock, lock_flags);
        sprintf(buffer, "IBM CAPI Flash Storage Adapter");
        spin_unlock_irqrestore(host->host_lock, lock_flags);

        return buffer;
}


/**
 * cflash_queuecommand - Queue a mid-layer request
 * @shost:               scsi host struct
 * @scsi_cmd:            scsi command struct
 *
 * This function queues a request generated by the mid-layer.
 *
 * Return value:
 *      0 on success
 *      SCSI_MLQUEUE_DEVICE_BUSY if device is busy
 *      SCSI_MLQUEUE_HOST_BUSY if host is busy
 **/
static int cflash_queuecommand(struct Scsi_Host *shost,
                               struct scsi_cmnd *scsi_cmd)
{
        /* XXX: Dummy */
        return 0;
}

/**
 * cflash_eh_abort_handler - Abort a single op
 * @scsi_cmd:                scsi command struct
 *
 * Return value:
 *      SUCCESS / FAILED
 **/
static int cflash_eh_abort_handler(struct scsi_cmnd *scsi_cmd)
{
        int rc = FAILED;

        ENTER;
	/* XXX: Dummy */
        LEAVE;
        return rc;
}

/**
 * cflash_eh_device_reset_handler - Reset a single LUN
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_device_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        return rc;
}


/**
 * cflash_eh_target_reset_handler - Reset the target
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_target_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        return rc;
}

/**
 * cflash_eh_host_reset_handler - Reset the connection to the server
 * @cmd:        struct scsi_cmnd having problems
 *
 **/
static int cflash_eh_host_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = SUCCESS;
	/* XXX: Dummy */
        return rc;
}

/**
 * cflash_slave_alloc - Setup the device's task set value
 * @sdev:       struct scsi_device device to configure
 *
 * Set the device's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_slave_alloc(struct scsi_device *sdev)
{
        int rc = -ENXIO;
	/* XXX: Dummy */
	return rc;
}

/**
 * cflash_slave_configure - Configure the device
 * @sdev:       struct scsi_device device to configure
 *
 * Enable allow_restart for a device if it is a disk. Adjust the
 * queue_depth here also.
 *
 * Returns:
 *      0
 **/
static int cflash_slave_configure(struct scsi_device *sdev)
{
	/* XXX: Dummy */
	return 0;
}

/**
 * cflash_target_alloc - Setup the target's task set value
 * @starget:    struct scsi_target
 *
 * Set the target's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_target_alloc(struct scsi_target *starget)
{
	/* XXX: Dummy */
        return 0;
}

/**
 * cflash_scan_finished - Check if the device scan is done.
 * @shost:      scsi host struct
 * @time:       current elapsed time
 *
 * Returns:
 *      0 if scan is not done / 1 if scan is done
 **/
static int cflash_scan_finished(struct Scsi_Host *shost, unsigned long time)
{
        int done = 0;
	/* XXX: Dummy */
        return done;
}

/**
 * cflash_change_queue_depth - Change the device's queue depth
 * @sdev:       scsi device struct
 * @qdepth:     depth to set
 * @reason:     calling context
 *
 * Return value:
 *      actual depth set
 **/
static int cflash_change_queue_depth(struct scsi_device *sdev, int qdepth,
                                     int reason)
{
        if (reason != SCSI_QDEPTH_DEFAULT)
                return -EOPNOTSUPP;

        if (qdepth > CFLASH_MAX_CMDS_PER_LUN)
                qdepth = CFLASH_MAX_CMDS_PER_LUN;

        scsi_adjust_queue_depth(sdev, 0, qdepth);
        return sdev->queue_depth;
}

/**
 * cflash_change_queue_type - Change the device's queue type
 * @sdev:               scsi device struct
 * @tag_type:   type of tags to use
 *
 * Return value:
 *      actual queue type set
 **/
static int cflash_change_queue_type(struct scsi_device *sdev, int tag_type)
{
        if (sdev->tagged_supported) {
                scsi_set_tag_type(sdev, tag_type);

                if (tag_type)
                        scsi_activate_tcq(sdev, sdev->queue_depth);
                else
                        scsi_deactivate_tcq(sdev, sdev->queue_depth);
        } else
                tag_type = 0;

        return tag_type;
}


static ssize_t cflash_show_host_partition_name(struct device *dev,
					       struct device_attribute *attr,
					       char *buf)
{

	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_device_name(struct device *dev,
                                            struct device_attribute *attr,
					    char *buf)
{

	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_loc_code(struct device *dev,
                                         struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_drc_name(struct device *dev,
                                         struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_npiv_version(struct device *dev,
                                             struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_capabilities(struct device *dev,
                                             struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_show_log_level - Show the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_show_log_level(struct device *dev,
                                     struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_store_log_level - Change the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_store_log_level(struct device *dev,
                                      struct device_attribute *attr,
                                      const char *buf, size_t count)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_ioctl - IOCTL handler
 * @sdev:       scsi device struct
 * @cmd:        IOCTL cmd
 * @arg:        IOCTL arg
 *
 * Return value:
 *      0 on success / other on failure
 **/
static int cflash_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
{
	/* XXX - TODO: MRO - these are for example scaffolding */
	/* Brings up the question, how do we get to headers in surelock-sw? */
	#define CXL_MAGIC 0xCA
	#define DISK_ATTACH	_IOW(CXL_MAGIC, 0xA0, struct scsi_device)
	typedef	void	cflash_t;


	int	  rc;
	cflash_t *p_cflash;

	/* XXX - TODO: MRO - an example of how we can pull out 'our' handle */
	p_cflash = (cflash_t *)sdev->hostdata;

	switch (cmd) {
	/* XXX - TODO: MRO - regardless of if we do ioctl/sysfs, do we want a
	 * front-end handler for everything MC-related or do we want to dispatch
	 * inline with other command genres?
	 */
	case DISK_ATTACH:
		rc = cflash_disk_attach(sdev, arg);
		if (rc) {
			/* XXX - TODO: trace here */
			goto cflash_ioctl_exit;
		}

		break;
	default:
		/* XXX - TODO: MRO - do we pass along to another handler (ie:
		 * ata_sas_scsi_ioctl() a la ipr.c) ?
		 */
		rc = -EINVAL;
		break;
	}

cflash_ioctl_exit:
	/* XXX - TODO: trace here */
	return rc;
}

/* XXX - These are examples of attributes that will be pushed/populated in
 * sysfs, the last argument is the callback. We can use cflash_store_log_level
 * as an example. There is also a 'sdev_attrs' member of the scsi_host_template
 * structure. I'm thinking that might be more appropriate for us, at least for
 * the MC communications path.
 */
static DEVICE_ATTR(partition_name, S_IRUGO, cflash_show_host_partition_name, NULL);
static DEVICE_ATTR(device_name, S_IRUGO, cflash_show_host_device_name, NULL);
static DEVICE_ATTR(port_loc_code, S_IRUGO, cflash_show_host_loc_code, NULL);
static DEVICE_ATTR(drc_name, S_IRUGO, cflash_show_host_drc_name, NULL);
static DEVICE_ATTR(npiv_version, S_IRUGO, cflash_show_host_npiv_version, NULL);
static DEVICE_ATTR(capabilities, S_IRUGO, cflash_show_host_capabilities, NULL);
static DEVICE_ATTR(log_level, S_IRUGO | S_IWUSR,
                   cflash_show_log_level, cflash_store_log_level);

static struct device_attribute *cflash_attrs[] = {
        &dev_attr_partition_name,
        &dev_attr_device_name,
        &dev_attr_port_loc_code,
        &dev_attr_drc_name,
        &dev_attr_npiv_version,
        &dev_attr_capabilities,
        &dev_attr_log_level,
        NULL
};


static struct scsi_host_template driver_template = {
        .module = THIS_MODULE,
        .name = "IBM POWER CAPI Flash Adapter",
        .info = cflash_ioa_info,
	.ioctl = cflash_ioctl,
        .proc_name = CFLASH_NAME,
        .queuecommand = cflash_queuecommand,
        .eh_abort_handler = cflash_eh_abort_handler,
        .eh_device_reset_handler = cflash_eh_device_reset_handler,
        .eh_target_reset_handler = cflash_eh_target_reset_handler,
        .eh_host_reset_handler = cflash_eh_host_reset_handler,
        .slave_alloc = cflash_slave_alloc,
        .slave_configure = cflash_slave_configure,
        .target_alloc = cflash_target_alloc,
        .scan_finished = cflash_scan_finished,
        .change_queue_depth = cflash_change_queue_depth,
        .change_queue_type = cflash_change_queue_type,
        .cmd_per_lun = 16,
        .can_queue = CFLASH_MAX_REQUESTS_DEFAULT,
        .this_id = -1,
        .sg_tablesize = SG_ALL,
        .max_sectors = CFLASH_MAX_SECTORS,
        .use_clustering = ENABLE_CLUSTERING,
        .shost_attrs = cflash_attrs,
};

static struct pci_device_id cflash_pci_table[] = {
        { PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CORSA,
                PCI_VENDOR_ID_IBM, CFLASH_SUBS_DEV_ID, 0, 0, 0 },
        {}
};

/**
 * cflash_probe - Adapter hot plug add entry point
 *
 * Return value:
 *      0 on success / non-zero on failure
 **/
static int cflash_probe(struct pci_dev *pdev, const struct pci_device_id *dev_id)
{
	struct Scsi_Host *host;

	/* XXX - TODO: MRO - just added this temporarily to get rid of the unused
	 * compile warning for the driver_template struct.
	 */
	dev_info(&pdev->dev, "Found IOA with IRQ: %d\n", pdev->irq);
	host = scsi_host_alloc(&driver_template, sizeof(int));

	return 0;
}

/**
 * cflash_remove - IOA hot plug remove entry point
 * @pdev:       pci device struct
 *
 * Adapter hot plug remove entry point.
 *
 * Return value:
 *      none
 **/
static void cflash_remove(struct pci_dev *pdev)
{
        ENTER;

	/* XXX: Dummy */

        LEAVE;
}

/**
 * cflash_shutdown - Shutdown handler.
 * @pdev:       pci device struct
 *
 * This function is invoked upon system shutdown/reboot. It will issue
 * an adapter shutdown to the adapter to flush the write cache.
 *
 * Return value:
 *      none
 **/
static void cflash_shutdown(struct pci_dev *pdev)
{
	/* XXX: Dummy */
}


/**
 * cflash_pci_error_detected - Called when a PCI error is detected.
 * @pdev:       PCI device struct
 * @state:      PCI channel state
 *
 * Description: Called when a PCI error is detected.
 *
 * Return value:
 *      PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT
 */
static pci_ers_result_t cflash_pci_error_detected(struct pci_dev *pdev,
                                               pci_channel_state_t state)
{
        switch (state) {
        case pci_channel_io_frozen:
		/* XXX: Dummy */
                return PCI_ERS_RESULT_CAN_RECOVER;
        case pci_channel_io_perm_failure:
		/* XXX: Dummy */
                return PCI_ERS_RESULT_DISCONNECT;
                break;
        default:
                break;
        }
        return PCI_ERS_RESULT_NEED_RESET;
}


/**
 * cflash_pci_mmio_enabled - Called when MMIO has been re-enabled
 * @pdev:       PCI device struct
 *
 * Description: This routine is called to tell us that the MMIO
 * access to the IOA has been restored
 */
static pci_ers_result_t cflash_pci_mmio_enabled(struct pci_dev *pdev)
{
	/* XXX: Dummy */
        return PCI_ERS_RESULT_NEED_RESET;
}

/**
 * cflash_pci_slot_reset - Called when PCI slot has been reset.
 * @pdev:       PCI device struct
 *
 * Description: This routine is called by the pci error recovery
 * code after the PCI slot has been reset, just before we
 * should resume normal operations.
 */
static pci_ers_result_t cflash_pci_slot_reset(struct pci_dev *pdev)
{
	/* XXX: Dummy */
        return PCI_ERS_RESULT_RECOVERED;
}

static const struct pci_error_handlers cflash_err_handler = {
        .error_detected = cflash_pci_error_detected,
        .mmio_enabled = cflash_pci_mmio_enabled,
        .slot_reset = cflash_pci_slot_reset,
};

static struct pci_driver cflash_driver = {
        .name = CFLASH_NAME,
        .id_table = cflash_pci_table,
        .probe = cflash_probe,
        .remove = cflash_remove,
        .shutdown = cflash_shutdown,
        .err_handler = &cflash_err_handler,
};


/**
 * cflash_halt - Issue shutdown prepare to all adapters
 *
 * Return value:
 *      NOTIFY_OK on success / NOTIFY_DONE on failure
 **/
static int cflash_halt(struct notifier_block *nb, ulong event, void *buf)
{
	/* XXX: Dummy */
	return NOTIFY_OK;
}

static struct notifier_block cflash_notifier = {
        cflash_halt, NULL, 0
};

static int __init init_cflash(void)
{
        cflash_info("IBM Power CAPI Flash Adapter version: %s %s\n",
                 CFLASH_DRIVER_VERSION, CFLASH_DRIVER_DATE);

        register_reboot_notifier(&cflash_notifier);
        return pci_register_driver(&cflash_driver);
}

static void exit_cflash(void)
{
        unregister_reboot_notifier(&cflash_notifier);
        pci_unregister_driver(&cflash_driver);
}

module_init(init_cflash);
module_exit(exit_cflash);

