
/*
* Copyright 2015 IBM Corp.
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version
* 2 of the License, or (at your option) any later version.
*/
#include <linux/pci.h>
#include <linux/module.h>
#include <linux/module.h>
#include <linux/semaphore.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_tcq.h>
#include <scsi/scsi_eh.h>
#include <scsi/scsi_cmnd.h>

static unsigned int cflash_debug = 0;

#include "cflash.h"

MODULE_DESCRIPTION("IBM CAPI Flash Adapter Driver");
MODULE_AUTHOR("Manoj Kumar <kumarmn@us.ibm.com>");
MODULE_AUTHOR("Paul Prahl <prahl@us.ibm.com>");
MODULE_AUTHOR("Matthew Ochs <mrochs@us.ibm.com>");
MODULE_LICENSE("GPL");


static int __init init_cflash(void)
{
	int rc = 0;
	return rc;
}

static void exit_cflash(void)
{
}


/**
 * cflash_ioa_info - Get information about the card/driver
 * @scsi_host:       scsi host struct
 *
 * Return value:
 *      pointer to buffer with description string
 **/
static const char *cflash_ioa_info(struct Scsi_Host *host)
{
        static char buffer[512];
        unsigned long lock_flags = 0;

        spin_lock_irqsave(host->host_lock, lock_flags);
        sprintf(buffer, "IBM CAPI Flash Storage Adapter");
        spin_unlock_irqrestore(host->host_lock, lock_flags);

        return buffer;
}


/**
 * cflash_queuecommand - Queue a mid-layer request
 * @shost:               scsi host struct
 * @scsi_cmd:            scsi command struct
 *
 * This function queues a request generated by the mid-layer.
 *
 * Return value:
 *      0 on success
 *      SCSI_MLQUEUE_DEVICE_BUSY if device is busy
 *      SCSI_MLQUEUE_HOST_BUSY if host is busy
 **/
static int cflash_queuecommand(struct Scsi_Host *shost,
                               struct scsi_cmnd *scsi_cmd)
{
        /* XXX: Dummy */
        return 0;
}

/**
 * cflash_eh_abort_handler - Abort a single op
 * @scsi_cmd:                scsi command struct
 *
 * Return value:
 *      SUCCESS / FAILED
 **/
static int cflash_eh_abort_handler(struct scsi_cmnd *scsi_cmd)
{
        int rc = FAILED;

        ENTER;
	/* XXX: Dummy */
        LEAVE;
        return rc;
}

/**
 * cflash_eh_device_reset_handler - Reset a single LUN
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_device_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        return rc;
}


/**
 * cflash_eh_target_reset_handler - Reset the target
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_target_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        return rc;
}

/**
 * cflash_eh_host_reset_handler - Reset the connection to the server
 * @cmd:        struct scsi_cmnd having problems
 *
 **/
static int cflash_eh_host_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = SUCCESS;
	/* XXX: Dummy */
        return rc;
}

/**
 * cflash_slave_alloc - Setup the device's task set value
 * @sdev:       struct scsi_device device to configure
 *
 * Set the device's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_slave_alloc(struct scsi_device *sdev)
{
        int rc = -ENXIO;
	/* XXX: Dummy */
	return rc;
}

/**
 * cflash_slave_configure - Configure the device
 * @sdev:       struct scsi_device device to configure
 *
 * Enable allow_restart for a device if it is a disk. Adjust the
 * queue_depth here also.
 *
 * Returns:
 *      0
 **/
static int cflash_slave_configure(struct scsi_device *sdev)
{
	/* XXX: Dummy */
	return 0;
}

/**
 * cflash_target_alloc - Setup the target's task set value
 * @starget:    struct scsi_target
 *
 * Set the target's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_target_alloc(struct scsi_target *starget)
{
	/* XXX: Dummy */
        return 0;
}

/**
 * cflash_scan_finished - Check if the device scan is done.
 * @shost:      scsi host struct
 * @time:       current elapsed time
 *
 * Returns:
 *      0 if scan is not done / 1 if scan is done
 **/
static int cflash_scan_finished(struct Scsi_Host *shost, unsigned long time)
{
        int done = 0;
	/* XXX: Dummy */
        return done;
}

/**
 * cflash_change_queue_depth - Change the device's queue depth
 * @sdev:       scsi device struct
 * @qdepth:     depth to set
 * @reason:     calling context
 *
 * Return value:
 *      actual depth set
 **/
static int cflash_change_queue_depth(struct scsi_device *sdev, int qdepth,
                                     int reason)
{
        if (reason != SCSI_QDEPTH_DEFAULT)
                return -EOPNOTSUPP;

        if (qdepth > CFLASH_MAX_CMDS_PER_LUN)
                qdepth = CFLASH_MAX_CMDS_PER_LUN;

        scsi_adjust_queue_depth(sdev, 0, qdepth);
        return sdev->queue_depth;
}

/**
 * cflash_change_queue_type - Change the device's queue type
 * @sdev:               scsi device struct
 * @tag_type:   type of tags to use
 *
 * Return value:
 *      actual queue type set
 **/
static int cflash_change_queue_type(struct scsi_device *sdev, int tag_type)
{
        if (sdev->tagged_supported) {
                scsi_set_tag_type(sdev, tag_type);

                if (tag_type)
                        scsi_activate_tcq(sdev, sdev->queue_depth);
                else
                        scsi_deactivate_tcq(sdev, sdev->queue_depth);
        } else
                tag_type = 0;

        return tag_type;
}


static ssize_t cflash_show_host_partition_name(struct device *dev,
                                                 struct device_attribute *attr, char *buf)
{

	/* XXX: Dummy */
 
        return 0;
}

static ssize_t cflash_show_host_device_name(struct device *dev,
                                            struct device_attribute *attr, char *buf)
{

	/* XXX: Dummy */
 
        return 0;
}

static ssize_t cflash_show_host_loc_code(struct device *dev,
                                         struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */
 
        return 0;
}

static ssize_t cflash_show_host_drc_name(struct device *dev,
                                         struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */
 
        return 0;
}

static ssize_t cflash_show_host_npiv_version(struct device *dev,
                                             struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */
 
        return 0;
}

static ssize_t cflash_show_host_capabilities(struct device *dev,
                                             struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */
 
        return 0;
}

/**
 * cflash_show_log_level - Show the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_show_log_level(struct device *dev,
                                     struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */
 
        return 0;
}

/**
 * cflash_store_log_level - Change the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_store_log_level(struct device *dev,
                                      struct device_attribute *attr,
                                      const char *buf, size_t count)
{
	/* XXX: Dummy */
 
        return 0;
}


static DEVICE_ATTR(partition_name, S_IRUGO, cflash_show_host_partition_name, NULL);
static DEVICE_ATTR(device_name, S_IRUGO, cflash_show_host_device_name, NULL);
static DEVICE_ATTR(port_loc_code, S_IRUGO, cflash_show_host_loc_code, NULL);
static DEVICE_ATTR(drc_name, S_IRUGO, cflash_show_host_drc_name, NULL);
static DEVICE_ATTR(npiv_version, S_IRUGO, cflash_show_host_npiv_version, NULL);
static DEVICE_ATTR(capabilities, S_IRUGO, cflash_show_host_capabilities, NULL);
static DEVICE_ATTR(log_level, S_IRUGO | S_IWUSR,
                   cflash_show_log_level, cflash_store_log_level);

static struct device_attribute *cflash_attrs[] = {
        &dev_attr_partition_name,
        &dev_attr_device_name,
        &dev_attr_port_loc_code,
        &dev_attr_drc_name,
        &dev_attr_npiv_version,
        &dev_attr_capabilities,
        &dev_attr_log_level,
        NULL
};


static struct scsi_host_template driver_template = {
        .module = THIS_MODULE,
        .name = "IBM POWER CAPI Flash Adapter",
        .info = cflash_ioa_info,
        .proc_name = CFLASH_NAME,
        .queuecommand = cflash_queuecommand,
        .eh_abort_handler = cflash_eh_abort_handler,
        .eh_device_reset_handler = cflash_eh_device_reset_handler,
        .eh_target_reset_handler = cflash_eh_target_reset_handler,
        .eh_host_reset_handler = cflash_eh_host_reset_handler,
        .slave_alloc = cflash_slave_alloc,
        .slave_configure = cflash_slave_configure,
        .target_alloc = cflash_target_alloc,
        .scan_finished = cflash_scan_finished,
        .change_queue_depth = cflash_change_queue_depth,
        .change_queue_type = cflash_change_queue_type,
        .cmd_per_lun = 16,
        .can_queue = CFLASH_MAX_REQUESTS_DEFAULT,
        .this_id = -1,
        .sg_tablesize = SG_ALL,
        .max_sectors = CFLASH_MAX_SECTORS,
        .use_clustering = ENABLE_CLUSTERING,
        .shost_attrs = cflash_attrs,
};

module_init(init_cflash);
module_exit(exit_cflash);

