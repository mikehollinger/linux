
/*
* Copyright 2015 IBM Corp.
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version
* 2 of the License, or (at your option) any later version.
*/
#include <linux/pci.h>
#include <linux/module.h>
#include <linux/semaphore.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/libata.h>
#include <linux/reboot.h>

#include <misc/cxl.h>
#include <uapi/misc/cxl.h>

#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_tcq.h>
#include <scsi/scsi_eh.h>
#include <scsi/scsi_cmnd.h>

#include "cflash.h"
#include "cflash.h"
#include "sislite.h"
#include "cflash_mc.h"
#include "cflash_ba.h"
#include "mserv.h"

MODULE_DESCRIPTION("IBM CAPI Flash Adapter Driver");
MODULE_AUTHOR("Manoj Kumar <kumarmn@us.ibm.com>");
MODULE_AUTHOR("Matthew R. Ochs <mrochs@us.ibm.com>");
MODULE_LICENSE("GPL");

unsigned int cflash_debug = 0;

/**
 * cflash_info - Get information about the card/driver
 * @scsi_host:       scsi host struct
 *
 * Return value:
 *      pointer to buffer with description string
 **/
static const char *cflash_driver_info(struct Scsi_Host *host)
{
        static char buffer[512];
        unsigned long lock_flags = 0;

        spin_lock_irqsave(host->host_lock, lock_flags);
        sprintf(buffer, "IBM CAPI Flash Storage Adapter");
        spin_unlock_irqrestore(host->host_lock, lock_flags);

        return buffer;
}


/**
 * cflash_queuecommand - Queue a mid-layer request
 * @shost:               scsi host struct
 * @scsi_cmd:            scsi command struct
 *
 * This function queues a request generated by the mid-layer.
 *
 * Return value:
 *      0 on success
 *      SCSI_MLQUEUE_DEVICE_BUSY if device is busy
 *      SCSI_MLQUEUE_HOST_BUSY if host is busy
 **/
static int cflash_queuecommand(struct Scsi_Host *shost,
                               struct scsi_cmnd *scsi_cmd)
{
        /* XXX: Dummy */
        return 0;
}

/**
 * cflash_eh_abort_handler - Abort a single op
 * @scsi_cmd:                scsi command struct
 *
 * Return value:
 *      SUCCESS / FAILED
 **/
static int cflash_eh_abort_handler(struct scsi_cmnd *scsi_cmd)
{
        int rc = FAILED;

        ENTER;
	/* XXX: Dummy */
        LEAVE;
        return rc;
}

/**
 * cflash_eh_device_reset_handler - Reset a single LUN
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_device_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        return rc;
}


/**
 * cflash_eh_target_reset_handler - Reset the target
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_target_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        return rc;
}

/**
 * cflash_eh_host_reset_handler - Reset the connection to the server
 * @cmd:        struct scsi_cmnd having problems
 *
 **/
static int cflash_eh_host_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = SUCCESS;
	/* XXX: Dummy */
        return rc;
}

/**
 * cflash_slave_alloc - Setup the device's task set value
 * @sdev:       struct scsi_device device to configure
 *
 * Set the device's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_slave_alloc(struct scsi_device *sdev)
{
        int rc = -ENXIO;
	/* XXX: Dummy */
	return rc;
}

/**
 * cflash_slave_configure - Configure the device
 * @sdev:       struct scsi_device device to configure
 *
 * Enable allow_restart for a device if it is a disk. Adjust the
 * queue_depth here also.
 *
 * Returns:
 *      0
 **/
static int cflash_slave_configure(struct scsi_device *sdev)
{
	/* XXX: Dummy */
	return 0;
}

/**
 * cflash_target_alloc - Setup the target's task set value
 * @starget:    struct scsi_target
 *
 * Set the target's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_target_alloc(struct scsi_target *starget)
{
	/* XXX: Dummy */
        return 0;
}

/**
 * cflash_scan_finished - Check if the device scan is done.
 * @shost:      scsi host struct
 * @time:       current elapsed time
 *
 * Returns:
 *      0 if scan is not done / 1 if scan is done
 **/
static int cflash_scan_finished(struct Scsi_Host *shost, unsigned long time)
{
        int done = 0;
	/* XXX: Dummy */
        return done;
}

/**
 * cflash_change_queue_depth - Change the device's queue depth
 * @sdev:       scsi device struct
 * @qdepth:     depth to set
 * @reason:     calling context
 *
 * Return value:
 *      actual depth set
 **/
static int cflash_change_queue_depth(struct scsi_device *sdev, int qdepth,
                                     int reason)
{
        if (reason != SCSI_QDEPTH_DEFAULT)
                return -EOPNOTSUPP;

        if (qdepth > CFLASH_MAX_CMDS_PER_LUN)
                qdepth = CFLASH_MAX_CMDS_PER_LUN;

        scsi_adjust_queue_depth(sdev, 0, qdepth);
        return sdev->queue_depth;
}

/**
 * cflash_change_queue_type - Change the device's queue type
 * @sdev:               scsi device struct
 * @tag_type:   type of tags to use
 *
 * Return value:
 *      actual queue type set
 **/
static int cflash_change_queue_type(struct scsi_device *sdev, int tag_type)
{
        if (sdev->tagged_supported) {
                scsi_set_tag_type(sdev, tag_type);

                if (tag_type)
                        scsi_activate_tcq(sdev, sdev->queue_depth);
                else
                        scsi_deactivate_tcq(sdev, sdev->queue_depth);
        } else
                tag_type = 0;

        return tag_type;
}


static ssize_t cflash_show_host_partition_name(struct device *dev,
					       struct device_attribute *attr,
					       char *buf)
{

	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_device_name(struct device *dev,
                                            struct device_attribute *attr,
					    char *buf)
{

	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_loc_code(struct device *dev,
                                         struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_drc_name(struct device *dev,
                                         struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_npiv_version(struct device *dev,
                                             struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_capabilities(struct device *dev,
                                             struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_show_log_level - Show the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_show_log_level(struct device *dev,
                                     struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_store_log_level - Change the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_store_log_level(struct device *dev,
                                      struct device_attribute *attr,
                                      const char *buf, size_t count)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_wait_for_pci_err_recovery - Wait for any PCI error recovery to
 *					complete during probe time
 * @p_cflash:    cflash config struct
 * 
 * Return value:
 *	None
 */
static void cflash_wait_for_pci_err_recovery(cflash_t *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;

	if (pci_channel_offline(pdev)) {
		wait_event_timeout(p_cflash->eeh_wait_q, 
				   !pci_channel_offline(pdev),
				   CFLASH_PCI_ERROR_RECOVERY_TIMEOUT);
		pci_restore_state(pdev);
	}
}

/**
 * cflash_ioctl - IOCTL handler
 * @sdev:       scsi device struct
 * @cmd:        IOCTL cmd
 * @arg:        IOCTL arg
 *
 * Return value:
 *      0 on success / other on failure
 **/
static int cflash_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
{
	/* XXX - TODO: MRO - these are for example scaffolding */
	/* Brings up the question, how do we get to headers in surelock-sw? */
	cflash_t *p_cflash;
	int	  rc;

	/* XXX - TODO: MRO - an example of how we can pull out 'our' handle */
	p_cflash = (cflash_t *)sdev->hostdata;

	switch (cmd) {
	/* XXX - TODO: MRO - regardless of if we do ioctl/sysfs, do we want a
	 * front-end handler for everything MC-related or do we want to 
	 * dispatch inline with other command genres?
	 */
	case DK_CAPI_ATTACH:
		rc = cflash_disk_attach(sdev, arg);
		if (rc) {
			/* XXX - TODO: trace here */
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_USER_DIRECT:
	case DK_CAPI_USER_VIRTUAL:
		rc = cflash_mc_register(sdev, arg);
		if (rc) {
			/* XXX - TODO: trace here */
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_DETACH:
		rc = cflash_mc_unregister(sdev, arg);
		if (rc) {
			/* XXX - TODO: trace here */
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_VLUN_RESIZE:
		rc = cflash_mc_size(sdev, arg);
		if (rc) {
			/* XXX - TODO: trace here */
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_RELEASE:
		rc = cflash_mc_close(sdev, arg);
		if (rc) {
			/* XXX - TODO: trace here */
			goto cflash_ioctl_exit;
		}

		break;
	default:
		/* XXX - TODO: MRO - do we pass along to another handler (ie:
		 * ata_sas_scsi_ioctl() a la ipr.c) ?
		 */
		rc = -EINVAL;
		break;
	}

cflash_ioctl_exit:
	/* XXX - TODO: trace here */
	return rc;
}

/* XXX - These are examples of attributes that will be pushed/populated in
 * sysfs, the last argument is the callback. We can use cflash_store_log_level
 * as an example. There is also a 'sdev_attrs' member of the scsi_host_template
 * structure. I'm thinking that might be more appropriate for us, at least for
 * the MC communications path.
 */
static DEVICE_ATTR(partition_name, S_IRUGO, cflash_show_host_partition_name, NULL);
static DEVICE_ATTR(device_name, S_IRUGO, cflash_show_host_device_name, NULL);
static DEVICE_ATTR(port_loc_code, S_IRUGO, cflash_show_host_loc_code, NULL);
static DEVICE_ATTR(drc_name, S_IRUGO, cflash_show_host_drc_name, NULL);
static DEVICE_ATTR(npiv_version, S_IRUGO, cflash_show_host_npiv_version, NULL);
static DEVICE_ATTR(capabilities, S_IRUGO, cflash_show_host_capabilities, NULL);
static DEVICE_ATTR(log_level, S_IRUGO | S_IWUSR,
                   cflash_show_log_level, cflash_store_log_level);

static struct device_attribute *cflash_attrs[] = {
        &dev_attr_partition_name,
        &dev_attr_device_name,
        &dev_attr_port_loc_code,
        &dev_attr_drc_name,
        &dev_attr_npiv_version,
        &dev_attr_capabilities,
        &dev_attr_log_level,
        NULL
};


static struct scsi_host_template driver_template = {
        .module = THIS_MODULE,
        .name = "IBM POWER CAPI Flash Adapter",
        .info = cflash_driver_info,
	.ioctl = cflash_ioctl,
        .proc_name = CFLASH_NAME,
        .queuecommand = cflash_queuecommand,
        .eh_abort_handler = cflash_eh_abort_handler,
        .eh_device_reset_handler = cflash_eh_device_reset_handler,
        .eh_target_reset_handler = cflash_eh_target_reset_handler,
        .eh_host_reset_handler = cflash_eh_host_reset_handler,
        .slave_alloc = cflash_slave_alloc,
        .slave_configure = cflash_slave_configure,
        .target_alloc = cflash_target_alloc,
        .scan_finished = cflash_scan_finished,
        .change_queue_depth = cflash_change_queue_depth,
        .change_queue_type = cflash_change_queue_type,
        .cmd_per_lun = 16,
        .can_queue = CFLASH_MAX_REQUESTS_DEFAULT,
        .this_id = -1,
        .sg_tablesize = SG_NONE, /* No scatter gather support. */
        .max_sectors = CFLASH_MAX_SECTORS,
        .use_clustering = ENABLE_CLUSTERING,
        .shost_attrs = cflash_attrs,
};

static struct pci_device_id cflash_pci_table[] = {
        { PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CORSA,
                PCI_VENDOR_ID_IBM, CFLASH_SUBS_DEV_ID, 0, 0, 0 },
        {}
};


/**
 * cflash_free_mem - Frees memory allocated for an adapter
 * @ioa_cfg:    ioa cfg struct
 *
 * Return value:
 *      nothing
 **/
static void cflash_free_mem(cflash_t *p_cflash)
{
	/* XXX: Dummy */
	return;
}

/**
 * cflash_remove - CFLASH hot plug remove entry point
 * @pdev:       pci device struct
 *
 * Adapter hot plug remove entry point.
 *
 * Return value:
 *      none
 **/
static void cflash_remove(struct pci_dev *pdev)
{
        cflash_t *p_cflash = pci_get_drvdata(pdev);
        ENTER;

	/* XXX: Dummy */

        scsi_remove_host(p_cflash->host);

	iounmap(p_cflash->cflash_regs);
	pci_release_regions(p_cflash->p_dev); 
	cflash_free_mem(p_cflash); 
	scsi_host_put(p_cflash->host); 
	pci_disable_device(p_cflash->p_dev);

	cflash_term_afu(p_cflash);

        LEAVE;
}


static int cflash_gb_alloc(cflash_t *p_cflash)
{
    int nafu = CFLASH_NAFU;
    int nbytes;
    struct capikv_ini *p_ini;
    struct capikv_ini_elm *p_elm;
    int i=0;
    int rc=0;

    nbytes = sizeof(*p_ini) +
            ((nafu > 1) ? (nafu - 1)*sizeof(*p_elm) : 0);

    p_cflash->p_ini = p_ini = (struct capikv_ini *) kzalloc(nbytes, GFP_KERNEL);
    if (p_ini == NULL) {
            cflash_dbg("cannot allocate %d bytes\n", nbytes);
            rc = ENOMEM;
	    goto out;
    }

    p_ini->sini_marker = 0x53494e49;
    p_ini->nelm = nafu;
    p_ini->size = sizeof(*p_elm);

    for (i = 0; i < nafu; i++) {
            p_elm = &p_ini->elm[i];
            // for this mode, the user enters the master dev path.
            // also assume wwpns are already programmed off-line and
            // master should leave them alone
            //
            p_elm->elmd_marker = 0x454c4d44;
            // XXX strcpy(&p_elm->afu_dev_pathm[0], argv[i + optind]);
            // XXX p_elm->lun_id = lun_id;
    }

    nbytes =  sizeof(struct afu_alloc) * p_ini->nelm;
    p_cflash->p_afu_a = (struct afu_alloc *) kzalloc(nbytes, GFP_KERNEL);

out:
    return rc;
}

static int cflash_init_pci(cflash_t *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int	rc = 0;

	p_cflash->cflash_regs_pci = pci_resource_start(pdev, 0);
	rc = pci_request_regions(pdev, CFLASH_NAME);
	if (rc < 0) {
		dev_err(&pdev->dev,
			"Couldn't register memory range of registers\n");
		 goto out;
	}

	rc = pci_enable_device(pdev);

	if (rc || pci_channel_offline(pdev)) {
		if (pci_channel_offline(pdev)) {
			cflash_wait_for_pci_err_recovery(p_cflash);
			rc = pci_enable_device(pdev);
		}

		if (rc) {
			dev_err(&pdev->dev, "Cannot enable adapter\n");
			cflash_wait_for_pci_err_recovery(p_cflash);
			goto out_release_regions;
		}
	}

	p_cflash->cflash_regs = pci_ioremap_bar(pdev, 0);

	if (!p_cflash->cflash_regs) {
		dev_err(&pdev->dev,
			"Couldn't map memory range of registers\n");
		rc = -ENOMEM;
		goto out_disable;
	}

	pci_set_master(pdev);

	if (pci_channel_offline(pdev)) {
		 cflash_wait_for_pci_err_recovery(p_cflash);
		 pci_set_master(pdev);
		 if (pci_channel_offline(pdev)) {
			 rc = -EIO;
			 goto out_msi_disable;
		 }
	}

	/* Save away PCI config space for use following CFLASH reset */
	rc = pci_save_state(pdev);

	if (rc != PCIBIOS_SUCCESSFUL) {
		dev_err(&pdev->dev, "Failed to save PCI config space\n");
		rc = -EIO;
		goto cleanup_nolog;
	}
	
out:
	return rc;

cleanup_nolog:
	/* XXX: free up any resources allocated here.
	cflash_free_mem(p_cflash);
	*/
out_msi_disable:
	cflash_wait_for_pci_err_recovery(p_cflash);
	iounmap(p_cflash->cflash_regs);
out_disable:
	pci_disable_device(pdev);
out_release_regions:
	pci_release_regions(pdev);
	goto out;

}

/**
 * cflash_scan_vsets - Scans for VSET devices
 * @p_cflash:    cflash_t config struct
 *
 * Description: Since the VSET resources do not follow SAM in that we can have
 * sparse LUNs with no LUN 0, we have to scan for these ourselves.
 *
 * Return value:
 *      none
 **/
static void cflash_scan_vsets(cflash_t *p_cflash)
{
        int target, lun;

        for (target = 0; target < CFLASH_MAX_NUM_TARGETS_PER_BUS; target++)
                for (lun = 0; lun < CFLASH_MAX_NUM_VSET_LUNS_PER_TARGET; lun++)
                        scsi_add_device(p_cflash->host, CFLASH_VSET_BUS, target, lun);
}

static int cflash_init_scsi(cflash_t *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int rc = 0;

	rc = scsi_add_host(p_cflash->host, &pdev->dev);
	if (rc) {
		cflash_remove(pdev);
		goto out;
	}

	scsi_scan_host(p_cflash->host);
	cflash_scan_vsets(p_cflash);
	scsi_add_device(p_cflash->host, CFLASH_BUS, CFLASH_TARGET,
			CFLASH_LUN);

out:
	return rc;
}

/**
 * cflash_probe - Adapter hot plug add entry point
 *
 * Return value:
 *      0 on success / non-zero on failure
 **/
static int cflash_probe(struct pci_dev *pdev, 
			const struct pci_device_id *dev_id)
{
	struct Scsi_Host *host;
	cflash_t *p_cflash = NULL;
	int	rc = 0;

        ENTER;

	dev_info(&pdev->dev, "Found CFLASH with IRQ: %d\n", pdev->irq);
	host = scsi_host_alloc(&driver_template, sizeof(cflash_t));

        if (!host) {
                dev_err(&pdev->dev, "call to scsi_host_alloc failed!\n");
                rc = -ENOMEM;
                goto out;
        }

        p_cflash = (cflash_t *)host->hostdata;
	rc = cflash_gb_alloc(p_cflash);
	if (rc)
	{
                dev_err(&pdev->dev, "call to scsi_host_alloc failed!\n");
                rc = -ENOMEM;
                goto out;
	}

	p_cflash->p_dev = pdev;
	p_cflash->p_dev_id = (struct pci_device_id *)dev_id;
	pci_set_drvdata(pdev, p_cflash);

#ifdef NEWCXL
	/* XXX: How to adderess both the AFUs on the CORSA */
	p_cflash->afu = cxl_pci_to_afu(pdev, NULL);
	cflash_init_afu(p_cflash);

	/* XXX: Add threads for afu_rrq_rx and afu_err_rx */
	/* after creating afu_err_rx thread, unmask error interrupts */
	afu_err_intr_init(&p_cflash->p_afu_a->afu);

#endif /* NEWCXL */

	rc = cflash_init_pci(p_cflash);
	if (rc) {
		goto out_remove;
	}

	rc = cflash_init_scsi(p_cflash);
	if (rc) {
		goto out_remove;
	}

        LEAVE;
out:
	return rc;

out_remove:
	cflash_remove(pdev);
        scsi_host_put(host);
        goto out;
}

/**
 * cflash_shutdown - Shutdown handler.
 * @pdev:       pci device struct
 *
 * This function is invoked upon system shutdown/reboot. It will issue
 * an adapter shutdown to the adapter to flush the write cache.
 *
 * Return value:
 *      none
 **/
static void cflash_shutdown(struct pci_dev *pdev)
{
	/* XXX: Dummy */
}


/**
 * cflash_pci_error_detected - Called when a PCI error is detected.
 * @pdev:       PCI device struct
 * @state:      PCI channel state
 *
 * Description: Called when a PCI error is detected.
 *
 * Return value:
 *      PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT
 */
static pci_ers_result_t cflash_pci_error_detected(struct pci_dev *pdev,
                                               pci_channel_state_t state)
{
        switch (state) {
        case pci_channel_io_frozen:
		/* XXX: Dummy */
                return PCI_ERS_RESULT_CAN_RECOVER;
        case pci_channel_io_perm_failure:
		/* XXX: Dummy */
                return PCI_ERS_RESULT_DISCONNECT;
                break;
        default:
                break;
        }
        return PCI_ERS_RESULT_NEED_RESET;
}


/**
 * cflash_pci_mmio_enabled - Called when MMIO has been re-enabled
 * @pdev:       PCI device struct
 *
 * Description: This routine is called to tell us that the MMIO
 * access to the CFLASH has been restored
 */
static pci_ers_result_t cflash_pci_mmio_enabled(struct pci_dev *pdev)
{
	/* XXX: Dummy */
        return PCI_ERS_RESULT_NEED_RESET;
}

/**
 * cflash_pci_slot_reset - Called when PCI slot has been reset.
 * @pdev:       PCI device struct
 *
 * Description: This routine is called by the pci error recovery
 * code after the PCI slot has been reset, just before we
 * should resume normal operations.
 */
static pci_ers_result_t cflash_pci_slot_reset(struct pci_dev *pdev)
{
	/* XXX: Dummy */
        return PCI_ERS_RESULT_RECOVERED;
}

static const struct pci_error_handlers cflash_err_handler = {
        .error_detected = cflash_pci_error_detected,
        .mmio_enabled = cflash_pci_mmio_enabled,
        .slot_reset = cflash_pci_slot_reset,
};

static struct pci_driver cflash_driver = {
        .name = CFLASH_NAME,
        .id_table = cflash_pci_table,
        .probe = cflash_probe,
        .remove = cflash_remove,
        .shutdown = cflash_shutdown,
        .err_handler = &cflash_err_handler,
};


/**
 * cflash_halt - Issue shutdown prepare to all adapters
 *
 * Return value:
 *      NOTIFY_OK on success / NOTIFY_DONE on failure
 **/
static int cflash_halt(struct notifier_block *nb, ulong event, void *buf)
{
	/* XXX: Dummy */
	return NOTIFY_OK;
}

static struct notifier_block cflash_notifier = {
        cflash_halt, NULL, 0
};

static int __init init_cflash(void)
{
        cflash_info("IBM Power CAPI Flash Adapter version: %s %s\n",
                 CFLASH_DRIVER_VERSION, CFLASH_DRIVER_DATE);

        register_reboot_notifier(&cflash_notifier);
        return pci_register_driver(&cflash_driver);
}

static void exit_cflash(void)
{
        unregister_reboot_notifier(&cflash_notifier);
        pci_unregister_driver(&cflash_driver);
}

module_init(init_cflash);
module_exit(exit_cflash);

