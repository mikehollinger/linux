/*
 * CAPI Flash Device Driver
 *
 * Written by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>, IBM Corporation
 *             Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation
 *
 * Copyright (C) 2015 IBM Corporation
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 */

#include <linux/pci.h>
#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/semaphore.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/libata.h>
#include <linux/reboot.h>

#include <misc/cxl.h>
#include <uapi/misc/cxl.h>

#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_tcq.h>
#include <scsi/scsi_eh.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/scsi_transport_fc.h>

#include "cflash.h"
#include "afu_fc.h"
#include "sislite.h"
#include "cflash_mc.h"
#include "cflash_ba.h"
#include "cflash_ioctl.h"
#include "mserv.h"

MODULE_DESCRIPTION("IBM CAPI Flash Adapter Driver");
MODULE_AUTHOR("Manoj N. Kumar <manoj@linux.vnet.ibm.com>");
MODULE_AUTHOR("Matthew R. Ochs <mrochs@linux.vnet.ibm.com>");
MODULE_LICENSE("GPL");

u32 internal_lun = 0;
module_param_named(lun_mode, internal_lun, uint, 0);
MODULE_PARM_DESC(lun_mode, " 0 = external LUN[s](default),\n"
			   " 1 = internal LUN (1 x 64K, 512B blocks, id 0),\n"
			   " 2 = internal LUN (1 x 64K, 4K blocks, id 0),\n"
			   " 3 = internal LUN (2 x 32K, 512B blocks, ids 0,1),\n"
			   " 4 = internal LUN (2 x 32K, 4K blocks, ids 0,1)");
module_param_named(debug, cflash_debug, uint, 0);
MODULE_PARM_DESC(debug, " 1 = enabled");


unsigned int cflash_debug = 0;

/**
 * cflash_driver_info - Get information about the card/driver
 * @scsi_host:       scsi host struct
 *
 * Return value:
 *      pointer to buffer with description string
 **/
static const char *cflash_driver_info(struct Scsi_Host *host)
{
	static char buffer[512];
	unsigned long lock_flags = 0;

	spin_lock_irqsave(host->host_lock, lock_flags);
	sprintf(buffer, "IBM CAPI Flash Storage Adapter");
	spin_unlock_irqrestore(host->host_lock, lock_flags);

	return buffer;
}

struct afu_cmd *get_next_cmd(struct afu *p_afu)
{
	int i;
	struct afu_cmd *p_cmd;
	unsigned long lock_flags = 0;

	/* The last command structure is reserved for SYNC */
	for (i=0; i<NUM_CMDS-1; i++) {
		p_cmd = &p_afu->cmd[i];
		spin_lock_irqsave(p_cmd->slock, lock_flags);

		if (p_cmd->flag == CMD_FREE) {
			p_cmd->flag = CMD_IN_USE;
			spin_unlock_irqrestore(p_cmd->slock, lock_flags);
			cflash_info("in %s returning found index=%d\n",
				    __func__, p_cmd->slot);
			return p_cmd;
		}
		spin_unlock_irqrestore(p_cmd->slock, lock_flags);
	}
	return  NULL;

}

void release_cmd(struct afu_cmd *p_cmd)
{
	unsigned long lock_flags = 0;

	spin_lock_irqsave(p_cmd->slock, lock_flags);
	p_cmd->flag = CMD_FREE;
	p_cmd->special = 0;
	spin_unlock_irqrestore(p_cmd->slock, lock_flags);
	cflash_info("in %s releasing cmd index=%d\n", __func__, p_cmd->slot);

}

/**
 * cflash_queuecommand_lck - Queue a mid-layer request
 * @shost:               scsi host struct
 * @scsi_cmd:            scsi command struct
 *
 * This function queues a request generated by the mid-layer.
 *
 * Return value:
 *      0 on success
 *      SCSI_MLQUEUE_DEVICE_BUSY if device is busy
 *      SCSI_MLQUEUE_HOST_BUSY if host is busy
 **/
static int cflash_queuecommand_lck(struct scsi_cmnd *scp,
				   void (*done) (struct scsi_cmnd *))
{
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	/* XXX: Until the scsi_dma_map works, this stuff is meaningless
	 * Make the queuecommand entry point a dummy one for now.
	 */
	scp->scsi_done = done;
	scp->scsi_done(scp);
	return 0;
	cflash_info("in %s (scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)\n",
		    __func__, scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->scsi_done = done;
	scp->result = (DID_OK << 16);;
	cflash_send_scsi(p_afu, scp);
	return 0;
}

static DEF_SCSI_QCMD(cflash_queuecommand)

/**
 * cflash_eh_abort_handler - Abort a single op
 * @scsi_cmd:                scsi command struct
 *
 * Return value:
 *      SUCCESS / FAILED
 **/
static int cflash_eh_abort_handler(struct scsi_cmnd *scp)
{
	int rc = FAILED;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	cflash_info("in %s (scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)\n",
		    __func__, scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_send_scsi(p_afu, scp);

	/* XXX: Return FAILED until we know the AFU reset works */
	cflash_info("in %s returning rc=%d\n", __func__, rc);
	return rc;
}

/**
 * cflash_eh_device_reset_handler - Reset a single LUN
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_device_reset_handler(struct scsi_cmnd *scp)
{
	int rc = FAILED;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	cflash_info("in %s (scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)\n",
		    __func__, scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_send_tmf(p_afu, scp, TMF_LUN_RESET);

	/* XXX: Return FAILED until we know the AFU reset works */
	cflash_info("in %s returning rc=%d\n", __func__, rc);
	return rc;
}

/**
 * cflash_eh_target_reset_handler - Reset the target
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_target_reset_handler(struct scsi_cmnd *scp)
{
	int rc = FAILED;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	cflash_info("in %s (scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)\n",
		    __func__, scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_send_scsi(p_afu, scp);

	/* XXX: Return FAILED until we know the AFU reset works */
	cflash_info("in %s returning rc=%d\n", __func__, rc);
	return rc;
}

/**
 * cflash_eh_host_reset_handler - Reset the connection to the server
 * @cmd:        struct scsi_cmnd having problems
 *
 **/
static int cflash_eh_host_reset_handler(struct scsi_cmnd *scp)
{
	int rc = SUCCESS;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	cflash_info("in %s (scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)\n",
		    __func__, scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_send_scsi(p_afu, scp);

	cflash_info("in %s returning rc=%d\n", __func__, rc);
	return rc;
}

void init_lun_info(struct lun_info *p_lun_info)
{
	memset(p_lun_info, 0, sizeof(struct lun_info));

	p_lun_info->lun_id = -1ULL;
	p_lun_info->lfd = -1;

	spin_lock_init(&p_lun_info->_slock);
	p_lun_info->slock = &p_lun_info->_slock;
}

/**
 * cflash_slave_alloc - Setup the device's task set value
 * @sdev:       struct scsi_device device to configure
 *
 * Set the device's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_slave_alloc(struct scsi_device *sdev)
{
	struct lun_info *p_luninfo;
	struct Scsi_Host *shost = sdev->host;
	struct cflash *p_cflash = shost_priv(shost);
	struct afu *p_afu = p_cflash->p_afu;
	unsigned long flags = 0;
	int rc = 0;

	spin_lock_irqsave(shost->host_lock, flags);

	p_luninfo = &p_afu->lun_info[p_cflash->task_set];
	sdev->hostdata = p_luninfo;
	p_cflash->task_set++;

	spin_unlock_irqrestore(shost->host_lock, flags);

	cflash_info("in %s returning task_set %d luninfo %p sdev %p\n",
		    __func__, p_cflash->task_set, p_luninfo, sdev);
	return rc;
}

/**
 * cflash_slave_configure - Configure the device
 * @sdev:       struct scsi_device device to configure
 *
 * Enable allow_restart for a device if it is a disk. Adjust the
 * queue_depth here also.
 *
 * Returns:
 *      0
 **/
static int cflash_slave_configure(struct scsi_device *sdev)
{
	/* XXX: Dummy */
	int rc = 0;
	cflash_info("in %s returning rc=%d\n", __func__, rc);
	return 0;
}

/**
 * struct cflasharget_alloc - Setup the target's task set value
 * @starget:    struct scsi_target
 *
 * Set the target's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_target_alloc(struct scsi_target *starget)
{
	/* XXX: Dummy */
	int rc = 0;
	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
	struct cflash *p_cflash = shost_priv(shost);

	cflash_info("in %s returning rc=%d ts%d\n", __func__, rc,
		    p_cflash->task_set);
	return 0;
}

/**
 * cflash_scan_finished - Check if the device scan is done.
 * @shost:      scsi host struct
 * @time:       current elapsed time
 *
 * Returns:
 *      0 if scan is not done / 1 if scan is done
 **/
static int cflash_scan_finished(struct Scsi_Host *shost, unsigned long time)
{
	int done = 1;
	/* XXX: Dummy */
	cflash_info("in %s returning done=%d\n", __func__, done);
	return done;
}

/**
 * cflash_change_queue_depth - Change the device's queue depth
 * @sdev:       scsi device struct
 * @qdepth:     depth to set
 * @reason:     calling context
 *
 * Return value:
 *      actual depth set
 **/
static int cflash_change_queue_depth(struct scsi_device *sdev, int qdepth,
				     int reason)
{
	if (reason != SCSI_QDEPTH_DEFAULT)
		return -EOPNOTSUPP;

	if (qdepth > CFLASH_MAX_CMDS_PER_LUN)
		qdepth = CFLASH_MAX_CMDS_PER_LUN;

	scsi_adjust_queue_depth(sdev, 0, qdepth);
	return sdev->queue_depth;
}

/**
 * cflash_change_queue_type - Change the device's queue type
 * @sdev:               scsi device struct
 * @tag_type:   type of tags to use
 *
 * Return value:
 *      actual queue type set
 **/
static int cflash_change_queue_type(struct scsi_device *sdev, int tag_type)
{
	if (sdev->tagged_supported) {
		scsi_set_tag_type(sdev, tag_type);

		if (tag_type)
			scsi_activate_tcq(sdev, sdev->queue_depth);
		else
			scsi_deactivate_tcq(sdev, sdev->queue_depth);
	} else
		tag_type = 0;

	return tag_type;
}

static ssize_t cflash_show_port_status(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	struct Scsi_Host *shost = class_to_shost(dev);
	struct cflash *p_cflash = (struct cflash *)shost->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	char *disp_status;
	int rc;
	u32 port;
	u64 status;
	volatile u64 *p_fc_regs;

	rc = kstrtouint((attr->attr.name + 4), 10, &port);
	if (rc || (port > SURELOCK_NUM_FC_PORTS))
		return 0;

	p_fc_regs = &p_afu->p_afu_map->global.fc_regs[port][0];
	status =
	    (read_64(&p_fc_regs[FC_MTIP_STATUS / 8]) & FC_MTIP_STATUS_MASK);

	if (status == FC_MTIP_STATUS_ONLINE)
		disp_status = "online";
	else if (status == FC_MTIP_STATUS_OFFLINE)
		disp_status = "offline";
	else
		disp_status = "unknown";

	return snprintf(buf, PAGE_SIZE, "%s\n", disp_status);
}

static ssize_t cflash_show_host_partition_name(struct device *dev,
					       struct device_attribute *attr,
					       char *buf)
{

	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_device_name(struct device *dev,
					    struct device_attribute *attr,
					    char *buf)
{

	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_loc_code(struct device *dev,
					 struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_drc_name(struct device *dev,
					 struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_npiv_version(struct device *dev,
					     struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_capabilities(struct device *dev,
					     struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

	return 0;
}

/**
 * cflash_show_log_level - Show the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_show_log_level(struct device *dev,
				     struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */

	return 0;
}

/**
 * cflash_store_log_level - Change the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_store_log_level(struct device *dev,
				      struct device_attribute *attr,
				      const char *buf, size_t count)
{
	/* XXX: Dummy */

	return 0;
}

/**
 * cflash_wait_for_pci_err_recovery - Wait for any PCI error recovery to
 *					complete during probe time
 * @p_cflash:    cflash config struct
 *
 * Return value:
 *	None
 */
static void cflash_wait_for_pci_err_recovery(struct cflash *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;

	if (pci_channel_offline(pdev)) {
		wait_event_timeout(p_cflash->eeh_wait_q,
				   !pci_channel_offline(pdev),
				   CFLASH_PCI_ERROR_RECOVERY_TIMEOUT);
		pci_restore_state(pdev);
	}
}

static char *
decode_ioctl(int cmd)
{
	#define _CASE2STR(_x) case _x: return #_x

	switch (cmd) {
	_CASE2STR(DK_CAPI_ATTACH);
	_CASE2STR(DK_CAPI_USER_DIRECT);
	_CASE2STR(DK_CAPI_USER_VIRTUAL);
	_CASE2STR(DK_CAPI_DETACH);
	_CASE2STR(DK_CAPI_VLUN_RESIZE);
	_CASE2STR(DK_CAPI_RELEASE);
	_CASE2STR(DK_CAPI_CLONE);
	}

	return("UNKNOWN");
}

/**
 * cflash_ioctl - IOCTL handler
 * @sdev:       scsi device struct
 * @cmd:        IOCTL cmd
 * @arg:        IOCTL arg
 *
 * Return value:
 *      0 on success / other on failure
 **/
static int cflash_ioctl(struct scsi_device *sdev, int cmd, void __user * arg)
{
	struct cflash *p_cflash;
	int rc;

	p_cflash = (struct cflash *)sdev->hostdata;

	/* Restrict command set to physical support only for internal LUN */
	if (internal_lun)
	{
		switch (cmd) {
		case DK_CAPI_USER_VIRTUAL:
		case DK_CAPI_VLUN_RESIZE:
		case DK_CAPI_RELEASE:
		case DK_CAPI_CLONE:
			cflash_err("%s not supported for lun_mode=%d\n",
				   decode_ioctl(cmd), internal_lun);
			rc = -EOPNOTSUPP;
			goto cflash_ioctl_exit;
		}
	}

	switch (cmd) {
	case DK_CAPI_ATTACH:
		rc = cflash_disk_attach(sdev, arg);
		break;
	case DK_CAPI_USER_DIRECT:
		rc = cflash_disk_open(sdev, arg, MODE_PHYSICAL);
		break;
	case DK_CAPI_USER_VIRTUAL:
		rc = cflash_disk_open(sdev, arg, MODE_VIRTUAL);
		break;
	case DK_CAPI_DETACH:
		rc = cflash_disk_detach(sdev, arg);
		break;
	case DK_CAPI_VLUN_RESIZE:
		rc = cflash_vlun_resize(sdev, arg);
		break;
	case DK_CAPI_RELEASE:
		rc = cflash_disk_release(sdev, arg);
		break;
	case DK_CAPI_CLONE:
		rc = cflash_disk_clone(sdev, arg);
		break;
	default:
		rc = -EOPNOTSUPP;
		break;
	}

	/* fall thru to exit */

cflash_ioctl_exit:
	cflash_info("ioctl %s (%08X) returned rc %d\n",
		    decode_ioctl(cmd), cmd, rc);
	return rc;
}

/* XXX - These are examples of attributes that will be pushed/populated in
 * sysfs, the last argument is the callback. We can use cflash_store_log_level
 * as an example. There is also a 'sdev_attrs' member of the scsi_host_template
 * structure. I'm thinking that might be more appropriate for us, at least for
 * the MC communications path.
 */
static DEVICE_ATTR(partition_name, S_IRUGO, cflash_show_host_partition_name,
		   NULL);
static DEVICE_ATTR(device_name, S_IRUGO, cflash_show_host_device_name, NULL);
static DEVICE_ATTR(port_loc_code, S_IRUGO, cflash_show_host_loc_code, NULL);
static DEVICE_ATTR(drc_name, S_IRUGO, cflash_show_host_drc_name, NULL);
static DEVICE_ATTR(npiv_version, S_IRUGO, cflash_show_host_npiv_version, NULL);
static DEVICE_ATTR(capabilities, S_IRUGO, cflash_show_host_capabilities, NULL);
static DEVICE_ATTR(log_level, S_IRUGO | S_IWUSR,
		   cflash_show_log_level, cflash_store_log_level);
static DEVICE_ATTR(port0, S_IRUGO, cflash_show_port_status, NULL);
static DEVICE_ATTR(port1, S_IRUGO, cflash_show_port_status, NULL);

static struct device_attribute *cflash_attrs[] = {
	&dev_attr_port0,
	&dev_attr_port1,
	&dev_attr_partition_name,
	&dev_attr_device_name,
	&dev_attr_port_loc_code,
	&dev_attr_drc_name,
	&dev_attr_npiv_version,
	&dev_attr_capabilities,
	&dev_attr_log_level,
	NULL
};

static struct scsi_host_template driver_template = {
	.module = THIS_MODULE,
	.name = "IBM POWER CAPI Flash Adapter",
	.info = cflash_driver_info,
	.ioctl = cflash_ioctl,
	.proc_name = CFLASH_NAME,
	.queuecommand = cflash_queuecommand,
	.eh_abort_handler = cflash_eh_abort_handler,
	.eh_device_reset_handler = cflash_eh_device_reset_handler,
	.eh_target_reset_handler = cflash_eh_target_reset_handler,
	.eh_host_reset_handler = cflash_eh_host_reset_handler,
	.slave_alloc = cflash_slave_alloc,
	.slave_configure = cflash_slave_configure,
	.target_alloc = cflash_target_alloc,
	.scan_finished = cflash_scan_finished,
	.change_queue_depth = cflash_change_queue_depth,
	.change_queue_type = cflash_change_queue_type,
	.cmd_per_lun = 16,
	.can_queue = CFLASH_MAX_REQUESTS_DEFAULT,
	.this_id = -1,
	.sg_tablesize = SG_NONE,	/* No scatter gather support. */
	.max_sectors = CFLASH_MAX_SECTORS,
	.use_clustering = ENABLE_CLUSTERING,
	.shost_attrs = cflash_attrs,
};

static struct pci_device_id cflash_pci_table[] = {
	{PCI_DEVICE(PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CORSA),},
	{}
};

/**
 * cflash_free_mem - Frees memory allocated for an adapter
 * @p_cflash:    struct cflash reference
 *
 * Return value:
 *      nothing
 **/
static void cflash_free_mem(struct cflash *p_cflash)
{
	int i, nbytes;
	char *buf = NULL;

	if (p_cflash->p_afu) {
		for (i=0; i<NUM_CMDS; i++) {
			buf = p_cflash->p_afu->cmd[i].buf;
			if (buf)
				free_pages((unsigned long)buf,
					   get_order(CMD_BUFSIZE));
		}

		nbytes = sizeof(struct afu) * CFLASH_NAFU;
		free_pages((unsigned long)p_cflash->p_afu, get_order(nbytes));
		p_cflash->p_afu = NULL;
	}

	return;
}

/**
 * cflash_remove - CFLASH hot plug remove entry point
 * @pdev:       pci device struct
 *
 * Adapter hot plug remove entry point.
 *
 * Return value:
 *      none
 **/
static void cflash_remove(struct pci_dev *pdev)
{
	struct cflash *p_cflash = pci_get_drvdata(pdev);
	ENTER;

	dev_err(&pdev->dev, "enter cflash_remove!\n");

	/* Use this for now to indicate that scsi_add_host() was performed */
	if (p_cflash->host->cmd_pool) {
		scsi_remove_host(p_cflash->host);
		dev_err(&pdev->dev, "after scsi_remove_host!\n");
	}

	cflash_term_afu(p_cflash);
	dev_err(&pdev->dev, "after struct cflash_term_afu !\n");

	/* XXX: Commented out for now
	   iounmap(p_cflash->cflash_regs);
	   pci_release_regions(p_cflash->p_dev);
	 */

	cflash_free_mem(p_cflash);
	scsi_host_put(p_cflash->host);
	dev_err(&pdev->dev, "after scsi_host_put!\n");

	/* XXX: Commented out for now
	   pci_disable_device(pdev);
	 */

	LEAVE;
}

static int cflash_gb_alloc(struct cflash *p_cflash)
{
	int nbytes;
	int rc = 0;
	int i;
	char *buf = NULL;

	nbytes = sizeof(struct afu) * CFLASH_NAFU;
	p_cflash->p_afu = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,
						   get_order(nbytes));
	if (!p_cflash->p_afu) {
		cflash_err("in %s cannot get %d free pages\n", __func__,
			   get_order(nbytes));
		rc = -ENOMEM;
		goto out;
	}

	/* Allocate one extra, just in case the SYNC command needs a buffer */
	for (i=0; i<NUM_CMDS; i++) {
		buf = (void *)__get_free_pages (GFP_KERNEL | __GFP_ZERO,
						get_order(CMD_BUFSIZE));
		if (!buf) {
			cflash_err("in %s cannot allocate command buffers %d\n",
				  __func__, CMD_BUFSIZE);
			rc = -ENOMEM;
			cflash_free_mem(p_cflash);
			goto out;
		}
		p_cflash->p_afu->cmd[i].buf = buf;
		p_cflash->p_afu->cmd[i].flag = CMD_FREE;
		p_cflash->p_afu->cmd[i].slot = i;
		p_cflash->p_afu->cmd[i].special = 0;
	}

out:
	return rc;
}

static int cflash_init_pci(struct cflash *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int rc = 0;

	p_cflash->cflash_regs_pci = pci_resource_start(pdev, 0);
	rc = pci_request_regions(pdev, CFLASH_NAME);
	if (rc < 0) {
		dev_err(&pdev->dev,
			"Couldn't register memory range of registers\n");
		goto out;
	}

	rc = pci_enable_device(pdev);
	if (rc || pci_channel_offline(pdev)) {
		if (pci_channel_offline(pdev)) {
			cflash_wait_for_pci_err_recovery(p_cflash);
			rc = pci_enable_device(pdev);
		}

		if (rc) {
			dev_err(&pdev->dev, "Cannot enable adapter\n");
			cflash_wait_for_pci_err_recovery(p_cflash);
			goto out_release_regions;
		}
	}

	/* XXX: Wait for Mikey to wire pci_set_dma_mask correctly
	   p_cflash->cflash_regs = pci_ioremap_bar(pdev, 0);

	   if (!p_cflash->cflash_regs) {
	   dev_err(&pdev->dev,
	   "Couldn't map memory range of registers\n");
	   rc = -ENOMEM;
	   goto out_disable;
	   }

	   rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
	   if (rc < 0) {
	   dev_dbg(&pdev->dev, "Failed to set 64 bit PCI DMA mask\n");
	   rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
	   }

	   if (rc < 0) {
	   dev_err(&pdev->dev, "Failed to set PCI DMA mask\n");
	   goto out_disable;
	   }
	 */

	rc = pci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, 0x20);

	if (rc != PCIBIOS_SUCCESSFUL) {
		dev_err(&pdev->dev, "Write of cache line size failed\n");
		cflash_wait_for_pci_err_recovery(p_cflash);

		rc = -EIO;
		goto out_disable;
	}

	pci_set_master(pdev);

	/*
	   if (pci_channel_offline(pdev)) {
	   cflash_wait_for_pci_err_recovery(p_cflash);
	   pci_set_master(pdev);
	   if (pci_channel_offline(pdev)) {
	   rc = -EIO;
	   goto out_msi_disable;
	   }

	 */

	/* Save away PCI config space for use following CFLASH reset
	   rc = pci_save_state(pdev);

	   if (rc != PCIBIOS_SUCCESSFUL) {
	   dev_err(&pdev->dev, "Failed to save PCI config space\n");
	   rc = -EIO;
	   goto cleanup_nolog;
	   }
	 */

out:
	cflash_info("in %s returning rc %d\n", __func__, rc);
	return rc;

cleanup_nolog:
	/* XXX: free up any resources allocated here.
	   cflash_free_mem(p_cflash);
	 */
out_msi_disable:
	cflash_wait_for_pci_err_recovery(p_cflash);
	iounmap(p_cflash->cflash_regs);
out_disable:
	pci_disable_device(pdev);
out_release_regions:
	pci_release_regions(pdev);
	goto out;

}

/**
 * cflash_scan_vsets - Scans for VSET devices
 * @p_cflash:    struct cflash config struct
 *
 * Description: Since the VSET resources do not follow SAM in that we can have
 * sparse LUNs with no LUN 0, we have to scan for these ourselves.
 *
 * Return value:
 *      none
 **/
static void cflash_scan_vsets(struct cflash *p_cflash)
{
	int j, rc;

	for (j = 0; j < NUM_FC_PORTS; j++) {	/* discover on each port */
		if ((rc = find_lun(p_cflash, 1u << j)) == 0) {
			cflash_info("Found valid lun on port=%d\n", j);
		} else {
			cflash_err("find_lun returned rc=%d on port=%d\n",
				   rc, j);
		}
	}
}

int cflash_init_ba(struct cflash *p_cflash, int lunindex)
{
	struct afu *p_afu = p_cflash->p_afu;
	struct lun_info *p_luninfo = &p_afu->lun_info[lunindex];
	int rc = 0;
	struct blka *p_blka = NULL;

	p_blka = kzalloc(sizeof(*p_blka), GFP_KERNEL);
	if (!p_blka) {
		cflash_err("Failed to get memory for block alloc!\n");
		rc = -ENOMEM;
		goto cflash_init_ba_exit;
	}

	mutex_init(&p_blka->mutex);

	p_blka->ba_lun.lun_id = p_luninfo->lun_id;
	p_blka->ba_lun.lsize = p_luninfo->li.max_lba + 1;
	p_blka->ba_lun.lba_size = p_luninfo->li.blk_len;

	p_blka->ba_lun.au_size = MC_CHUNK_SIZE;
	p_blka->nchunk = p_blka->ba_lun.lsize / MC_CHUNK_SIZE;

	rc = ba_init(&p_blka->ba_lun);
	if (rc) {
		cflash_err("cannot init block_alloc, rc %d\n", rc);
		goto cflash_init_ba_exit;
	}

	p_afu->p_blka[lunindex] = p_blka;

cflash_init_ba_exit:
	if (rc && p_blka)
		kfree(p_blka);

	cflash_info("in %s returning index %d p_blka %p rc=%d\n",
		    __func__, lunindex, p_afu->p_blka[lunindex], rc);
	return rc;
}

static int cflash_init_scsi(struct cflash *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int rc = 0;

	dev_info(&pdev->dev, "in %s before scsi_add_host\n", __func__);
	rc = scsi_add_host(p_cflash->host, &pdev->dev);
	if (rc) {
		dev_err(&pdev->dev, "in %s, scsi_add_host() failed (rc=%d)\n",
			__func__, rc);
		goto out;
	}

	dev_info(&pdev->dev, "in %s before scsi_scan_host\n", __func__);
	scsi_scan_host(p_cflash->host);

	cflash_scan_vsets(p_cflash);

	/*
	   dev_info(&pdev->dev, "in %s before scsi_add_device\n", __func__);
	   scsi_add_device(p_cflash->host, CFLASH_BUS, CFLASH_TARGET,
	   CFLASH_LUN);
	 */

out:
	cflash_info("in %s returning rc %d\n", __func__, rc);
	return rc;
}

/**
 * cflash_probe - Adapter hot plug add entry point
 *
 * Return value:
 *      0 on success / non-zero on failure
 **/
static int cflash_probe(struct pci_dev *pdev,
			const struct pci_device_id *dev_id)
{
	struct Scsi_Host *host;
	struct cflash *p_cflash = NULL;
	struct device *phys_dev;
	int rc = 0;

	ENTER;

	dev_info(&pdev->dev, "Found CFLASH with IRQ: %d\n", pdev->irq);

	host = scsi_host_alloc(&driver_template, sizeof(struct cflash));

	if (!host) {
		dev_err(&pdev->dev, "call to scsi_host_alloc failed!\n");
		rc = -ENOMEM;
		goto out;
	}
	/* XXX: Need to double check with the sislite spec */
	host->max_id = CFLASH_MAX_NUM_TARGETS_PER_BUS;
	host->max_lun = CFLASH_MAX_NUM_VSET_LUNS_PER_TARGET;
	host->max_channel = CFLASH_BUS;
	host->unique_id = host->host_no;
	host->max_cmd_len = CFLASH_MAX_CDB_LEN;

	p_cflash = (struct cflash *)host->hostdata;
	p_cflash->host = host;
	rc = cflash_gb_alloc(p_cflash);
	if (rc) {
		dev_err(&pdev->dev, "call to scsi_host_alloc failed!\n");
		rc = -ENOMEM;
		goto out;
	}

	p_cflash->p_dev = pdev;
	p_cflash->last_lun_index = 0;
	p_cflash->task_set = 0;
	p_cflash->p_dev_id = (struct pci_device_id *)dev_id;
	p_cflash->tmf_active = 0;
        init_waitqueue_head(&p_cflash->tmf_wait_q);
	p_cflash->context_reset_active = 0;

	pci_set_drvdata(pdev, p_cflash);

	/* Use the special service provided to look up the physical
	 * PCI device, since we are called on the probe of the virtual
	 * PCI host bus (vphb)
	 */
	phys_dev = cxl_get_phys_dev(pdev);
	if (!dev_is_pci(phys_dev)) {	/* make sure it's pci */
		printk("not a pci dev\n");
		rc = ENODEV;
		goto out_remove;
	}
	p_cflash->parent_dev = to_pci_dev(phys_dev);

	p_cflash->afu = cxl_pci_to_afu(pdev, NULL);
	rc = cflash_init_afu(p_cflash);
	if (rc) {
		dev_err(&pdev->dev, "call to cflash_init_afu failed rc=%d!\n",
			rc);
		goto out_remove;
	}

	/* XXX: Add threads for afu_rrq_rx and afu_err_rx */
	/* after creating afu_err_rx thread, unmask error interrupts */
	afu_err_intr_init(p_cflash->p_afu);

	rc = cflash_init_pci(p_cflash);
	if (rc) {
		dev_err(&pdev->dev, "call to cflash_init_pci failed rc=%d!\n",
			rc);
		goto out_remove;
	}

	rc = cflash_init_scsi(p_cflash);
	if (rc) {
		dev_err(&pdev->dev, "call to cflash_init_scsi failed rc=%d!\n",
			rc);
		goto out_remove;
	}

	LEAVE;
out:
	cflash_info("in %s returning rc %d\n", __func__, rc);
	return rc;

out_remove:
	cflash_remove(pdev);
	goto out;
}

/**
 * cflash_shutdown - Shutdown handler.
 * @pdev:       pci device struct
 *
 * This function is invoked upon system shutdown/reboot. It will issue
 * an adapter shutdown to the adapter to flush the write cache.
 *
 * Return value:
 *      none
 **/
static void cflash_shutdown(struct pci_dev *pdev)
{
	/* XXX: Dummy */
}

/**
 * cflash_pci_error_detected - Called when a PCI error is detected.
 * @pdev:       PCI device struct
 * @state:      PCI channel state
 *
 * Description: Called when a PCI error is detected.
 *
 * Return value:
 *      PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT
 */
static pci_ers_result_t cflash_pci_error_detected(struct pci_dev *pdev,
						  pci_channel_state_t state)
{
	switch (state) {
	case pci_channel_io_frozen:
		/* XXX: Dummy */
		return PCI_ERS_RESULT_CAN_RECOVER;
	case pci_channel_io_perm_failure:
		/* XXX: Dummy */
		return PCI_ERS_RESULT_DISCONNECT;
		break;
	default:
		break;
	}
	return PCI_ERS_RESULT_NEED_RESET;
}

/**
 * cflash_pci_mmio_enabled - Called when MMIO has been re-enabled
 * @pdev:       PCI device struct
 *
 * Description: This routine is called to tell us that the MMIO
 * access to the CFLASH has been restored
 */
static pci_ers_result_t cflash_pci_mmio_enabled(struct pci_dev *pdev)
{
	/* XXX: Dummy */
	return PCI_ERS_RESULT_NEED_RESET;
}

/**
 * cflash_pci_slot_reset - Called when PCI slot has been reset.
 * @pdev:       PCI device struct
 *
 * Description: This routine is called by the pci error recovery
 * code after the PCI slot has been reset, just before we
 * should resume normal operations.
 */
static pci_ers_result_t cflash_pci_slot_reset(struct pci_dev *pdev)
{
	/* XXX: Dummy */
	return PCI_ERS_RESULT_RECOVERED;
}

static const struct pci_error_handlers cflash_err_handler = {
	.error_detected = cflash_pci_error_detected,
	.mmio_enabled = cflash_pci_mmio_enabled,
	.slot_reset = cflash_pci_slot_reset,
};

static struct pci_driver cflash_driver = {
	.name = CFLASH_NAME,
	.id_table = cflash_pci_table,
	.probe = cflash_probe,
	.remove = cflash_remove,
	.shutdown = cflash_shutdown,
	.err_handler = &cflash_err_handler,
};

/**
 * cflash_halt - Issue shutdown prepare to all adapters
 *
 * Return value:
 *      NOTIFY_OK on success / NOTIFY_DONE on failure
 **/
static int cflash_halt(struct notifier_block *nb, ulong event, void *buf)
{
	/* XXX: Dummy */
	return NOTIFY_OK;
}

static struct notifier_block cflash_notifier = {
	cflash_halt, NULL, 0
};

static int __init init_cflash(void)
{
	cflash_info("IBM Power CAPI Flash Adapter version: %s %s\n",
		    CFLASH_DRIVER_VERSION, CFLASH_DRIVER_DATE);

	/* Validate module parameters */
	if (internal_lun > 4) {
		cflash_err("Invalid lun_mode parameter! (%d > 4)\n",
			   internal_lun);
		return(-EINVAL);
	}
	if (cflash_debug > 1) {
		cflash_err("Invalid debug parameter! (%d > 1)\n",
			   cflash_debug);
		return(-EINVAL);
	}

	register_reboot_notifier(&cflash_notifier);
	return pci_register_driver(&cflash_driver);
}

static void exit_cflash(void)
{
	unregister_reboot_notifier(&cflash_notifier);
	pci_unregister_driver(&cflash_driver);
}

module_init(init_cflash);
module_exit(exit_cflash);
