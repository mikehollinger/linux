/*
 * CAPI Flash Device Driver
 *
 * Written by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>, IBM Corporation
 *             Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation
 *
 * Copyright (C) 2015 IBM Corporation
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 */

#include <linux/pci.h>
#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/semaphore.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/list.h>
#include <linux/libata.h>
#include <linux/reboot.h>

#include <misc/cxl.h>
#include <uapi/misc/cxl.h>

#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_tcq.h>
#include <scsi/scsi_eh.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/scsi_transport_fc.h>

#include "cflash.h"
#include "afu_fc.h"
#include "sislite.h"
#include "cflash_mc.h"
#include "cflash_ba.h"
#include "cflash_ioctl.h"
#include "cflash_util.h"
#include "mserv.h"

MODULE_DESCRIPTION("IBM CAPI Flash Adapter Driver");
MODULE_AUTHOR("Manoj N. Kumar <manoj@linux.vnet.ibm.com>");
MODULE_AUTHOR("Matthew R. Ochs <mrochs@linux.vnet.ibm.com>");
MODULE_LICENSE("GPL");

u32 internal_lun = 0;
u32 cflash_debug = 0;
u32 fullqc = 0;
u32 checkpid = 0;
module_param_named(lun_mode, internal_lun, uint, 0);
MODULE_PARM_DESC(lun_mode, " 0 = external LUN[s](default),\n"
			   " 1 = internal LUN (1 x 64K, 512B blocks, id 0),\n"
			   " 2 = internal LUN (1 x 64K, 4K blocks, id 0),\n"
			   " 3 = internal LUN (2 x 32K, 512B blocks, ids 0,1),\n"
			   " 4 = internal LUN (2 x 32K, 4K blocks, ids 0,1)");
module_param_named(debug, cflash_debug, uint, 0);
MODULE_PARM_DESC(debug, " 1 = enabled");

module_param_named(qc, fullqc, uint, 0);
MODULE_PARM_DESC(qc, " 1 = Regular SCSI queuecommand");

module_param_named(checkpid, checkpid, uint, 0);
MODULE_PARM_DESC(qc, " 1 = Enforce PID/context ownership policy");


/**
 * cflash_driver_info - Get information about the card/driver
 * @scsi_host:       scsi host struct
 *
 * Return value:
 *      pointer to buffer with description string
 **/
static const char *cflash_driver_info(struct Scsi_Host *host)
{
	static char buffer[512];
	unsigned long lock_flags = 0;

	spin_lock_irqsave(host->host_lock, lock_flags);
	sprintf(buffer, "IBM CAPI Flash Storage Adapter");
	spin_unlock_irqrestore(host->host_lock, lock_flags);

	return buffer;
}

/* Check out a command */
struct afu_cmd *cflash_cmd_cout(struct afu *p_afu)
{
	int i;
	struct afu_cmd *p_cmd;
	unsigned long lock_flags = 0;

	/* The last command structure is reserved for SYNC */
	for (i=0; i<CFLASH_MAX_CMDS-1; i++) {
		p_cmd = &p_afu->cmd[i];
		spin_lock_irqsave(p_cmd->slock, lock_flags);

		if (p_cmd->flag == CMD_FREE) {
			p_cmd->flag = CMD_IN_USE;
			spin_unlock_irqrestore(p_cmd->slock, lock_flags);
			cflash_dbg("returning found index=%d", p_cmd->slot);
			memset(p_cmd->buf, 0, CMD_BUFSIZE);
			memset(p_cmd->rcb.cdb, 0, sizeof(p_cmd->rcb.cdb));
			return p_cmd;
		}
		spin_unlock_irqrestore(p_cmd->slock, lock_flags);
	}
	return NULL;

}

/* Check in the command */
void cflash_cmd_cin(struct afu_cmd *p_cmd)
{
	unsigned long lock_flags = 0;

	spin_lock_irqsave(p_cmd->slock, lock_flags);
	p_cmd->flag = CMD_FREE;
	p_cmd->special = 0;
	spin_unlock_irqrestore(p_cmd->slock, lock_flags);
	cflash_dbg("releasing cmd index=%d", p_cmd->slot);

}

/**
 * cflash_queuecommand - Queue a mid-layer request
 * @shost:               scsi host struct
 * @scsi_cmd:            scsi command struct
 *
 * This function queues a request generated by the mid-layer.
 *
 * Return value:
 *      0 on success
 *      SCSI_MLQUEUE_DEVICE_BUSY if device is busy
 *      SCSI_MLQUEUE_HOST_BUSY if host is busy
 **/
static int cflash_queuecommand(struct Scsi_Host *host,
			       struct scsi_cmnd *scp)
{
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;
	int rc = 0;

	/* XXX: Until the scsi_dma_map works, this stuff is meaningless
	 * Make the queuecommand entry point a dummy one for now.
	 */

	switch (scp->cmnd[0]) {
	case REPORT_LUNS:
		cflash_info("REPORT_LUNS received!!!");
		break;
	case INQUIRY:
		cflash_info("INQUIRY received!!!");
		break;
	}

	if (!fullqc) {
		scp->scsi_done(scp);
	} else {
		cflash_info("(scp=%p) %d/%d/%d/%llu "
			"cdb=(%08x-%08x-%08x-%08x)", scp,
			host->host_no, scp->device->channel,
			scp->device->id, scp->device->lun,
			cpu_to_be32(((u32 *) scp->cmnd)[0]),
			cpu_to_be32(((u32 *) scp->cmnd)[1]),
			cpu_to_be32(((u32 *) scp->cmnd)[2]),
			cpu_to_be32(((u32 *) scp->cmnd)[3]));

		rc = cflash_send_scsi(p_afu, scp);
	}
	return rc;
}

/**
 * cflash_eh_abort_handler - Abort a single op
 * @scsi_cmd:                scsi command struct
 *
 * Return value:
 *      SUCCESS / FAILED
 **/
static int cflash_eh_abort_handler(struct scsi_cmnd *scp)
{
	int rc = FAILED;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	cflash_info("(scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)", scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_send_scsi(p_afu, scp);

	/* XXX: Return FAILED until we know the AFU reset works */
	cflash_info("returning rc=%d", rc);
	return rc;
}

/**
 * cflash_eh_device_reset_handler - Reset a single LUN
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_device_reset_handler(struct scsi_cmnd *scp)
{
	int rc = FAILED;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	cflash_info("(scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)", scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_send_tmf(p_afu, scp, TMF_LUN_RESET);

	/* XXX: Return FAILED until we know the AFU reset works */
	cflash_info("returning rc=%d", rc);
	return rc;
}

/**
 * cflash_eh_target_reset_handler - Reset the target
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_target_reset_handler(struct scsi_cmnd *scp)
{
	int rc = FAILED;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	cflash_info("(scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)", scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_send_scsi(p_afu, scp);

	/* XXX: Return FAILED until we know the AFU reset works */
	cflash_info("returning rc=%d", rc);
	return rc;
}

/**
 * cflash_eh_host_reset_handler - Reset the connection to the server
 * @cmd:        struct scsi_cmnd having problems
 *
 **/
static int cflash_eh_host_reset_handler(struct scsi_cmnd *scp)
{
	int rc = SUCCESS;
	struct Scsi_Host *host = scp->device->host;
	struct dk_capi_recover_afu arg = {0};

	cflash_info("(scp=%p) %d/%d/%d/%llu "
		    "cdb=(%08x-%08x-%08x-%08x)", scp,
		    host->host_no, scp->device->channel,
		    scp->device->id, scp->device->lun,
		    cpu_to_be32(((u32 *) scp->cmnd)[0]),
		    cpu_to_be32(((u32 *) scp->cmnd)[1]),
		    cpu_to_be32(((u32 *) scp->cmnd)[2]),
		    cpu_to_be32(((u32 *) scp->cmnd)[3]));

	scp->result = (DID_OK << 16);;
	cflash_afu_recover(scp->device, &arg);

	cflash_info("returning rc=%d", rc);
	return rc;
}

static struct lun_info *
create_lun_info(struct scsi_device *sdev)
{
	struct lun_info *p_lun_info = NULL;

	p_lun_info = kzalloc(sizeof(*p_lun_info), GFP_KERNEL);
	if (!p_lun_info) {
		cflash_err("could not allocate p_lun_info");
		goto create_lun_info_exit;
	}

	p_lun_info->sdev = sdev;

	spin_lock_init(&p_lun_info->_slock);
	p_lun_info->slock = &p_lun_info->_slock;

create_lun_info_exit:
	cflash_info("returning %p", p_lun_info);
	return p_lun_info;
}

/**
 * cflash_slave_alloc - Setup the device's task set value
 * @sdev:       struct scsi_device device to configure
 *
 * Set the device's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_slave_alloc(struct scsi_device *sdev)
{
	struct lun_info *p_lun_info = NULL;
	struct Scsi_Host *shost = sdev->host;
	struct cflash *p_cflash = shost_priv(shost);
	struct afu *p_afu = p_cflash->p_afu;
	unsigned long flags = 0;
	int rc = 0;

	spin_lock_irqsave(shost->host_lock, flags);

	p_lun_info = create_lun_info(sdev);
	if (!p_lun_info) {
		cflash_err("failed to allocate lun_info!");
		rc = -ENXIO;
		goto out;
	}

	sdev->hostdata = p_lun_info;
	list_add(&p_lun_info->list, &p_afu->luns);
out:
	spin_unlock_irqrestore(shost->host_lock, flags);

	cflash_info("returning task_set %d luninfo %p sdev %p",
		    p_cflash->task_set, p_lun_info, sdev);
	return rc;
}

/**
 * cflash_slave_configure - Configure the device
 * @sdev:       struct scsi_device device to configure
 *
 * Enable allow_restart for a device if it is a disk. Adjust the
 * queue_depth here also.
 *
 * Returns:
 *      0
 **/
static int cflash_slave_configure(struct scsi_device *sdev)
{
	struct lun_info *p_lun_info = sdev->hostdata;
	int rc = 0;

	cflash_info("ID = %08X", sdev->id);
	cflash_info("CHANNEL = %08X", sdev->channel);
	cflash_info("LUN = %016llX", sdev->lun);
	cflash_info("sector_size = %u", sdev->sector_size);

	/* Store off lun in unpacked, AFU-friendly format */
	p_lun_info->lun_id = lun_to_lunid(sdev->lun);
	cflash_info("LUN2 = %016llX", p_lun_info->lun_id);

	/*
	 * XXX - leaving this here for now as a reminder that read_cap16
	 * doesn't work in this path. We also need to figure out how and
	 * when to setup the LUN table (on attach coupled with where we
	 * now call read_cap16?) and also look into how we're skipping
	 * entries. The spec has a blurb about this but I'm not convinced
	 * we're doing it right.
	 */
#if 0
	if (fullqc) {
        	struct ctx_info *p_ctx_info;
        	struct rht_info *p_rht_info = NULL;
        	struct sisl_rht_entry *p_rht_entry = NULL;
	        u64 rsrc_handle = -1;
		struct Scsi_Host *shost = sdev->host;
		struct cflash *p_cflash = shost_priv(shost);
		struct afu *p_afu = p_cflash->p_afu;


		write_64(&p_afu->p_afu_map->global.fc_port[sdev->channel]
				 [p_cflash->last_lun_index++], p_lun_info->lun_id);
		//read_cap16(p_afu, p_lun_info, sdev->channel + 1);
		cflash_info("LBA = %016llX", p_lun_info->max_lba);
		cflash_info("BLK_LEN = %08X", p_lun_info->blk_len);

		rc = cflash_init_ba(p_lun_info);
		if (rc) {
			cflash_err("call to cflash_init_ba failed rc=%d!",
				   rc);
			rc = -ENOMEM;
			goto out;
		}
                p_ctx_info = get_validated_context(p_cflash, p_afu->ctx_hndl, 
						   FALSE);
		p_ctx_info->p_rht_info = &p_afu->rht_info[p_afu->ctx_hndl];
	        p_rht_entry  = cflash_rhte_cout(p_cflash, p_afu->ctx_hndl);
                p_rht_info = p_ctx_info->p_rht_info;
        	rsrc_handle = (p_rht_entry - p_rht_info->rht_start);
                cflash_rht_format1(p_rht_entry, p_lun_info->lun_id);
                afu_sync(p_afu, p_afu->ctx_hndl, rsrc_handle, AFU_LW_SYNC);
	}
#endif

	cflash_info("returning rc=%d", rc);
	return rc;
}

static void cflash_slave_destroy(struct scsi_device *sdev)
{
	struct lun_info *p_lun_info = sdev->hostdata;

	if (p_lun_info) {
		sdev->hostdata = NULL;
		list_del(&p_lun_info->list);
		ba_terminate(&p_lun_info->blka.ba_lun);
		kfree(p_lun_info);
	}

	cflash_info("p_lun_info=%p", p_lun_info);
	return;
}

/**
 * struct cflasharget_alloc - Setup the target's task set value
 * @starget:    struct scsi_target
 *
 * Set the target's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_target_alloc(struct scsi_target *starget)
{
	/* XXX: Dummy */
	int rc = 0;
	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
	struct cflash *p_cflash = shost_priv(shost);

	cflash_info("returning rc=%d ts%d", rc, p_cflash->task_set);
	return 0;
}

/**
 * cflash_scan_finished - Check if the device scan is done.
 * @shost:      scsi host struct
 * @time:       current elapsed time
 *
 * Returns:
 *      0 if scan is not done / 1 if scan is done
 **/
static int cflash_scan_finished(struct Scsi_Host *shost, unsigned long time)
{
	int done = 1;
	/* XXX: Dummy */
	cflash_info("returning done=%d", done);
	return done;
}

/**
 * cflash_change_queue_depth - Change the device's queue depth
 * @sdev:       scsi device struct
 * @qdepth:     depth to set
 * @reason:     calling context
 *
 * Return value:
 *      actual depth set
 **/
static int cflash_change_queue_depth(struct scsi_device *sdev, int qdepth)
{

	if (qdepth > CFLASH_MAX_CMDS_PER_LUN)
		qdepth = CFLASH_MAX_CMDS_PER_LUN;

	scsi_change_queue_depth(sdev, qdepth);
	return sdev->queue_depth;
}


static ssize_t cflash_show_port_status(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	struct Scsi_Host *shost = class_to_shost(dev);
	struct cflash *p_cflash = (struct cflash *)shost->hostdata;
	struct afu *p_afu = p_cflash->p_afu;

	char *disp_status;
	int rc;
	u32 port;
	u64 status;
	volatile u64 *p_fc_regs;

	rc = kstrtouint((attr->attr.name + 4), 10, &port);
	if (rc || (port > NUM_FC_PORTS))
		return 0;

	p_fc_regs = &p_afu->p_afu_map->global.fc_regs[port][0];
	status =
	    (read_64(&p_fc_regs[FC_MTIP_STATUS / 8]) & FC_MTIP_STATUS_MASK);

	if (status == FC_MTIP_STATUS_ONLINE)
		disp_status = "online";
	else if (status == FC_MTIP_STATUS_OFFLINE)
		disp_status = "offline";
	else
		disp_status = "unknown";

	return snprintf(buf, PAGE_SIZE, "%s\n", disp_status);
}

static ssize_t cflash_show_host_partition_name(struct device *dev,
					       struct device_attribute *attr,
					       char *buf)
{

	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_device_name(struct device *dev,
					    struct device_attribute *attr,
					    char *buf)
{

	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_loc_code(struct device *dev,
					 struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_drc_name(struct device *dev,
					 struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_npiv_version(struct device *dev,
					     struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

	return 0;
}

static ssize_t cflash_show_host_capabilities(struct device *dev,
					     struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

	return 0;
}

/**
 * cflash_show_log_level - Show the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_show_log_level(struct device *dev,
				     struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */

	return 0;
}

/**
 * cflash_store_log_level - Change the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_store_log_level(struct device *dev,
				      struct device_attribute *attr,
				      const char *buf, size_t count)
{
	/* XXX: Dummy */

	return 0;
}

/**
 * cflash_wait_for_pci_err_recovery - Wait for any PCI error recovery to
 *					complete during probe time
 * @p_cflash:    cflash config struct
 *
 * Return value:
 *	None
 */
static void cflash_wait_for_pci_err_recovery(struct cflash *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;

	if (pci_channel_offline(pdev)) {
		wait_event_timeout(p_cflash->eeh_wait_q,
				   !pci_channel_offline(pdev),
				   CFLASH_PCI_ERROR_RECOVERY_TIMEOUT);
		pci_restore_state(pdev);
	}
}

static char *
decode_ioctl(int cmd)
{
	#define _CASE2STR(_x) case _x: return #_x

	switch (cmd) {
	_CASE2STR(DK_CAPI_ATTACH);
	_CASE2STR(DK_CAPI_USER_DIRECT);
	_CASE2STR(DK_CAPI_USER_VIRTUAL);
	_CASE2STR(DK_CAPI_DETACH);
	_CASE2STR(DK_CAPI_VLUN_RESIZE);
	_CASE2STR(DK_CAPI_RELEASE);
	_CASE2STR(DK_CAPI_CLONE);
	}

	return("UNKNOWN");
}

/**
 * cflash_ioctl - IOCTL handler
 * @sdev:       scsi device struct
 * @cmd:        IOCTL cmd
 * @arg:        IOCTL arg
 *
 * Return value:
 *      0 on success / other on failure
 **/
static int cflash_ioctl(struct scsi_device *sdev, int cmd, void __user * arg)
{
	struct cflash *p_cflash;
	int rc;

	p_cflash = (struct cflash *)sdev->hostdata;

	/* Restrict command set to physical support only for internal LUN */
	if (internal_lun)
	{
		switch (cmd) {
		case DK_CAPI_USER_VIRTUAL:
		case DK_CAPI_VLUN_RESIZE:
		case DK_CAPI_RELEASE:
		case DK_CAPI_CLONE:
			cflash_err("%s not supported for lun_mode=%d",
				   decode_ioctl(cmd), internal_lun);
			rc = -EINVAL;
			goto cflash_ioctl_exit;
		}
	}

	switch (cmd) {
	case DK_CAPI_ATTACH:
		rc = cflash_disk_attach(sdev, arg);
		break;
	case DK_CAPI_USER_DIRECT:
		rc = cflash_disk_open(sdev, arg, MODE_PHYSICAL);
		break;
	case DK_CAPI_USER_VIRTUAL:
		rc = cflash_disk_open(sdev, arg, MODE_VIRTUAL);
		break;
	case DK_CAPI_DETACH:
		rc = cflash_disk_detach(sdev, arg);
		break;
	case DK_CAPI_VLUN_RESIZE:
		rc = cflash_vlun_resize(sdev, arg);
		break;
	case DK_CAPI_RELEASE:
		rc = cflash_disk_release(sdev, arg);
		break;
	case DK_CAPI_CLONE:
		rc = cflash_disk_clone(sdev, arg);
		break;
	case DK_CAPI_RECOVER_AFU:
		rc = cflash_afu_recover(sdev, arg);
		break;
	default:
		rc = -EINVAL;
		break;
	}

	/* fall thru to exit */

cflash_ioctl_exit:
	cflash_info("ioctl %s (%08X) returned rc %d",
		    decode_ioctl(cmd), cmd, rc);
	return rc;
}

/* XXX - These are examples of attributes that will be pushed/populated in
 * sysfs, the last argument is the callback. We can use cflash_store_log_level
 * as an example. There is also a 'sdev_attrs' member of the scsi_host_template
 * structure. I'm thinking that might be more appropriate for us, at least for
 * the MC communications path.
 */
static DEVICE_ATTR(partition_name, S_IRUGO, cflash_show_host_partition_name,
		   NULL);
static DEVICE_ATTR(device_name, S_IRUGO, cflash_show_host_device_name, NULL);
static DEVICE_ATTR(port_loc_code, S_IRUGO, cflash_show_host_loc_code, NULL);
static DEVICE_ATTR(drc_name, S_IRUGO, cflash_show_host_drc_name, NULL);
static DEVICE_ATTR(npiv_version, S_IRUGO, cflash_show_host_npiv_version, NULL);
static DEVICE_ATTR(capabilities, S_IRUGO, cflash_show_host_capabilities, NULL);
static DEVICE_ATTR(log_level, S_IRUGO | S_IWUSR,
		   cflash_show_log_level, cflash_store_log_level);
static DEVICE_ATTR(port0, S_IRUGO, cflash_show_port_status, NULL);
static DEVICE_ATTR(port1, S_IRUGO, cflash_show_port_status, NULL);

static struct device_attribute *cflash_attrs[] = {
	&dev_attr_port0,
	&dev_attr_port1,
	&dev_attr_partition_name,
	&dev_attr_device_name,
	&dev_attr_port_loc_code,
	&dev_attr_drc_name,
	&dev_attr_npiv_version,
	&dev_attr_capabilities,
	&dev_attr_log_level,
	NULL
};

static struct scsi_host_template driver_template = {
	.module = THIS_MODULE,
	.name = "IBM POWER CAPI Flash Adapter",
	.info = cflash_driver_info,
	.ioctl = cflash_ioctl,
	.proc_name = CFLASH_NAME,
	.queuecommand = cflash_queuecommand,
	.eh_abort_handler = cflash_eh_abort_handler,
	.eh_device_reset_handler = cflash_eh_device_reset_handler,
	.eh_target_reset_handler = cflash_eh_target_reset_handler,
	.eh_host_reset_handler = cflash_eh_host_reset_handler,
	.slave_alloc = cflash_slave_alloc,
	.slave_configure = cflash_slave_configure,
	.slave_destroy = cflash_slave_destroy,
	.target_alloc = cflash_target_alloc,
	.scan_finished = cflash_scan_finished,
	.change_queue_depth = cflash_change_queue_depth,
	.cmd_per_lun = 16,
	.can_queue = CFLASH_MAX_CMDS,
	.this_id = -1,
	.sg_tablesize = SG_NONE,	/* No scatter gather support. */
	.max_sectors = CFLASH_MAX_SECTORS,
	.use_clustering = ENABLE_CLUSTERING,
	.shost_attrs = cflash_attrs,
};

static struct pci_device_id cflash_pci_table[] = {
	{PCI_DEVICE(PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CORSA),},
	{}
};

/**
 * cflash_free_mem - Frees memory allocated for an adapter
 * @p_cflash:    struct cflash reference
 *
 * Return value:
 *      nothing
 **/
static void cflash_free_mem(struct cflash *p_cflash)
{
	int i, nbytes;
	char *buf = NULL;

	if (p_cflash->p_afu) {
		for (i=0; i<CFLASH_MAX_CMDS; i++) {
			timer_stop(&p_cflash->p_afu->cmd[i].timer, TRUE);
			buf = p_cflash->p_afu->cmd[i].buf;
			if (buf)
				free_pages((unsigned long)buf,
					   get_order(CMD_BUFSIZE));
		}

		nbytes = sizeof(struct afu) * CFLASH_NAFU;
		free_pages((unsigned long)p_cflash->p_afu, get_order(nbytes));
		p_cflash->p_afu = NULL;
	}

	return;
}

/**
 * cflash_remove - CFLASH hot plug remove entry point
 * @pdev:       pci device struct
 *
 * Adapter hot plug remove entry point.
 *
 * Return value:
 *      none
 **/
static void cflash_remove(struct pci_dev *pdev)
{
	struct cflash *p_cflash = pci_get_drvdata(pdev);
	struct Scsi_Host *host = p_cflash->host;
	unsigned long lock_flags = 0;

	cflash_dev_err(&pdev->dev, "enter cflash_remove!");

	spin_lock_irqsave(host->host_lock, lock_flags);
	while (p_cflash->tmf_active) {
		spin_unlock_irqrestore(host->host_lock, lock_flags);
		wait_event(p_cflash->tmf_wait_q, !p_cflash->tmf_active);
		spin_lock_irqsave(host->host_lock, lock_flags);
	}
	spin_unlock_irqrestore(host->host_lock, lock_flags);


	/* Use this for now to indicate that scsi_add_host() was performed */
	if (p_cflash->host->cmd_pool) {
		scsi_remove_host(p_cflash->host);
		cflash_dev_err(&pdev->dev, "after scsi_remove_host!");
	}

	cflash_term_afu(p_cflash);
	cflash_dbg("after struct cflash_term_afu!");

	/* XXX: Commented out for now
	   iounmap(p_cflash->cflash_regs);
	   pci_release_regions(p_cflash->p_dev);
	 */

	cflash_free_mem(p_cflash);
	scsi_host_put(p_cflash->host);
	cflash_dbg("after scsi_host_put!");

	/* XXX: Commented out for now
	   pci_disable_device(pdev);
	 */

	cflash_dbg("returning");
}

static int cflash_gb_alloc(struct cflash *p_cflash)
{
	int nbytes;
	int rc = 0;
	int i;
	char *buf = NULL;

	nbytes = sizeof(struct afu) * CFLASH_NAFU;
	p_cflash->p_afu = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,
						   get_order(nbytes));
	if (!p_cflash->p_afu) {
		cflash_err("cannot get %d free pages", get_order(nbytes));
		rc = -ENOMEM;
		goto out;
	}
	p_cflash->p_afu->p_afu_map = NULL;

	/* Allocate one extra, just in case the SYNC command needs a buffer */
	for (i=0; i<CFLASH_MAX_CMDS; i++) {
		buf = (void *)__get_free_pages (GFP_KERNEL | __GFP_ZERO,
						get_order(CMD_BUFSIZE));
		if (!buf) {
			cflash_err("cannot allocate command buffers %d",
				   CMD_BUFSIZE);
			rc = -ENOMEM;
			cflash_free_mem(p_cflash);
			goto out;
		}
		p_cflash->p_afu->cmd[i].buf = buf;
		p_cflash->p_afu->cmd[i].flag = CMD_FREE;
		p_cflash->p_afu->cmd[i].slot = i;
		p_cflash->p_afu->cmd[i].special = 0;
	}

	for  (i=0; i<MAX_CONTEXT; i++) {
		p_cflash->per_context[i].lfd = -1;
	}

out:
	return rc;
}

static int cflash_init_pci(struct cflash *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int rc = 0;

	p_cflash->cflash_regs_pci = pci_resource_start(pdev, 0);
	rc = pci_request_regions(pdev, CFLASH_NAME);
	if (rc < 0) {
		cflash_dev_err(&pdev->dev,
			"Couldn't register memory range of registers");
		goto out;
	}

	rc = pci_enable_device(pdev);
	if (rc || pci_channel_offline(pdev)) {
		if (pci_channel_offline(pdev)) {
			cflash_wait_for_pci_err_recovery(p_cflash);
			rc = pci_enable_device(pdev);
		}

		if (rc) {
			cflash_dev_err(&pdev->dev, "Cannot enable adapter");
			cflash_wait_for_pci_err_recovery(p_cflash);
			goto out_release_regions;
		}
	}

	/* XXX: Need to investigate
	   p_cflash->cflash_regs = pci_ioremap_bar(pdev, 0);

	   if (!p_cflash->cflash_regs) {
	   cflash_dev_err(&pdev->dev,
	   "Couldn't map memory range of registers");
	   rc = -ENOMEM;
	   goto out_disable;
	   }
	 */

	rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
	if (rc < 0) {
		cflash_dev_dbg(&pdev->dev, "Failed to set 64 bit PCI DMA mask");
		rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
	}

	if (rc < 0) {
		cflash_dev_err(&pdev->dev, "Failed to set PCI DMA mask");
		goto out_disable;
	}

	rc = pci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, 0x20);

	if (rc != PCIBIOS_SUCCESSFUL) {
		cflash_dev_err(&pdev->dev, "Write of cache line size failed");
		cflash_wait_for_pci_err_recovery(p_cflash);

		rc = -EIO;
		goto out_disable;
	}

	pci_set_master(pdev);

	/*
	   if (pci_channel_offline(pdev)) {
	   cflash_wait_for_pci_err_recovery(p_cflash);
	   pci_set_master(pdev);
	   if (pci_channel_offline(pdev)) {
	   rc = -EIO;
	   goto out_msi_disable;
	   }

	 */

	/* Save away PCI config space for use following CFLASH reset
	   rc = pci_save_state(pdev);

	   if (rc != PCIBIOS_SUCCESSFUL) {
	   cflash_dev_err(&pdev->dev, "Failed to save PCI config space");
	   rc = -EIO;
	   goto cleanup_nolog;
	   }
	 */

out:
	cflash_info("returning rc=%d", rc);
	return rc;

cleanup_nolog:
	/* XXX: free up any resources allocated here.
	   cflash_free_mem(p_cflash);
	 */
out_msi_disable:
	cflash_wait_for_pci_err_recovery(p_cflash);
	iounmap(p_cflash->cflash_regs);
out_disable:
	pci_disable_device(pdev);
out_release_regions:
	pci_release_regions(pdev);
	goto out;

}

/**
 * cflash_scan_luns - Scans For all LUNs on all Ports
 * @p_cflash:    struct cflash config struct
 *
 * Description: This will be deprecated when the kernel services
 * are ready.
 *
 * Return value:
 *      none
 **/
static void cflash_scan_luns(struct cflash *p_cflash)
{
	int j, rc;

	for (j = 0; j < NUM_FC_PORTS; j++) {	/* discover on each port */
		if ((rc = find_lun(p_cflash, 1u << j)) == 0) {
			cflash_info("Found valid lun on port=%d", j);
		} else {
			cflash_err("find_lun returned rc=%d on port=%d", rc, j);
		}
	}
}

static int cflash_init_scsi(struct cflash *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int rc = 0;

	cflash_dev_dbg(&pdev->dev, "before scsi_add_host");
	rc = scsi_add_host(p_cflash->host, &pdev->dev);
	if (rc) {
		cflash_dev_err(&pdev->dev, "scsi_add_host failed (rc=%d)", rc);
		goto out;
	}

	cflash_dev_dbg(&pdev->dev, "before scsi_scan_host");
	scsi_scan_host(p_cflash->host);

	if (!fullqc)
		cflash_scan_luns(p_cflash);

out:
	cflash_info("returning rc=%d", rc);
	return rc;
}

/* online means the FC link layer has sync and has completed the link
 * layer handshake. It is ready for login to start.
 */
void set_port_online(volatile u64 * p_fc_regs)
{
	u64 cmdcfg;

	cmdcfg = read_64(&p_fc_regs[FC_MTIP_CMDCONFIG / 8]);
	cmdcfg &= (~FC_MTIP_CMDCONFIG_OFFLINE);	/* clear OFF_LINE */
	cmdcfg |= (FC_MTIP_CMDCONFIG_ONLINE);	/* set ON_LINE */
	write_64(&p_fc_regs[FC_MTIP_CMDCONFIG / 8], cmdcfg);
}

void set_port_offline(volatile u64 * p_fc_regs)
{
	u64 cmdcfg;

	cmdcfg = read_64(&p_fc_regs[FC_MTIP_CMDCONFIG / 8]);
	cmdcfg &= (~FC_MTIP_CMDCONFIG_ONLINE);	/* clear ON_LINE */
	cmdcfg |= (FC_MTIP_CMDCONFIG_OFFLINE);	/* set OFF_LINE */
	write_64(&p_fc_regs[FC_MTIP_CMDCONFIG / 8], cmdcfg);
}

/* returns 1 - went online */
/* wait_port_xxx will timeout when cable is not pluggd in */
int wait_port_online(volatile u64 * p_fc_regs,
		     useconds_t delay_us, unsigned int nretry)
{
	u64 status;

	if (delay_us < 1000) {
		cflash_err("invalid delay specified %d", delay_us);
		return -EINVAL;
	}

	do {
		msleep(delay_us / 1000);
		status = read_64(&p_fc_regs[FC_MTIP_STATUS / 8]);
	} while ((status & FC_MTIP_STATUS_MASK) != FC_MTIP_STATUS_ONLINE &&
		 nretry--);

	return ((status & FC_MTIP_STATUS_MASK) == FC_MTIP_STATUS_ONLINE);
}

/* returns 1 - went offline */
int wait_port_offline(volatile u64 * p_fc_regs,
		      useconds_t delay_us, unsigned int nretry)
{
	u64 status;

	if (delay_us < 1000) {
		cflash_err("invalid delay specified %d", delay_us);
		return -EINVAL;
	}

	do {
		msleep(delay_us / 1000);
		status = read_64(&p_fc_regs[FC_MTIP_STATUS / 8]);
	} while ((status & FC_MTIP_STATUS_MASK) != FC_MTIP_STATUS_OFFLINE &&
		 nretry--);

	return ((status & FC_MTIP_STATUS_MASK) == FC_MTIP_STATUS_OFFLINE);
}

/* this function can block up to a few seconds */
int afu_set_wwpn(struct afu *p_afu, int port, volatile u64 * p_fc_regs,
		 u64 wwpn)
{
	int ret = 0;

	set_port_offline(p_fc_regs);

	if (!wait_port_offline(p_fc_regs, FC_PORT_STATUS_RETRY_INTERVAL_US,
			       FC_PORT_STATUS_RETRY_CNT)) {
		cflash_dbg("wait on port %d to go offline timed out", port);
		ret = -1; /* but continue on to leave the port back online */
	}

	if (ret == 0) {
		write_64(&p_fc_regs[FC_PNAME / 8], wwpn);
	}

	set_port_online(p_fc_regs);

	if (!wait_port_online(p_fc_regs, FC_PORT_STATUS_RETRY_INTERVAL_US,
			      FC_PORT_STATUS_RETRY_CNT)) {
		cflash_dbg("wait on port %d to go online timed out", port);
		ret = -1;

		/*
		 * Override for internal lun!!!
		 * XXX - is a wrap plug mandatory?
		 */
		if (internal_lun) {
			cflash_info("Overriding port %d online timeout!!!",
				    port);
			ret = 0;
		}
	}

	cflash_info("returning rc=%d", ret);

	return ret;
}

void cflash_stop_afu(struct cflash *p_cflash)
{
	int i;
	struct afu *p_afu = p_cflash->p_afu;

	if (p_afu == NULL) {
		cflash_info("returning because afu is NULl");
		return;
	}

	/* Need to stop timers before unmapping */
	for (i=0; i<CFLASH_MAX_CMDS; i++) {
		timer_stop(&p_cflash->p_afu->cmd[i].timer, TRUE);
	}

	if (p_afu->p_afu_map) {
		cxl_psa_unmap((void *)p_afu->p_afu_map);
		p_afu->p_afu_map = NULL;
	}
}

void afu_err_intr_init(struct afu *p_afu)
{
	int i;
	volatile u64 reg;

	/* global async interrupts: AFU clears afu_ctrl on context exit
	 * if async interrupts were sent to that context. This prevents
	 * the AFU form sending further async interrupts when
	 * there is
	 * nobody to receive them.
	 */

	/* mask all */
	write_64(&p_afu->p_afu_map->global.regs.aintr_mask, -1ull);
	/* set LISN# to send and point to master context */
	reg = ((u64)(((p_afu->ctx_hndl << 8) | SISL_MSI_ASYNC_ERROR)) << 40);

	if (internal_lun)
		reg |= 1; /* Bit 63 indicates local lun */
	write_64(&p_afu->p_afu_map->global.regs.afu_ctrl, reg);
	/* clear all */
	write_64(&p_afu->p_afu_map->global.regs.aintr_clear, -1ull);
	/* unmask bits that are of interest */
	/* note: afu can send an interrupt after this step */
	write_64(&p_afu->p_afu_map->global.regs.aintr_mask, SISL_ASTATUS_MASK);
	/* clear again in case a bit came on after previous clear but before */
	/* unmask */
	write_64(&p_afu->p_afu_map->global.regs.aintr_clear, -1ull);

	/* Clear/Set internal lun bits */
	reg = read_64(&p_afu->p_afu_map->global.fc_regs[0][FC_CONFIG2 / 8]);
	cflash_info("ilun p0 = %016llX", reg);
	reg &= ~(0x3ULL << 32);
	if (internal_lun)
		reg |= ((u64)(internal_lun - 1) << 32);
	cflash_info("ilun p0 = %016llX", reg);
	write_64(&p_afu->p_afu_map->global.fc_regs[0][FC_CONFIG2 / 8], reg);

	/* now clear FC errors */
	for (i = 0; i < NUM_FC_PORTS; i++) {
		write_64(&p_afu->p_afu_map->global.fc_regs[i][FC_ERROR / 8],
			 (u32) - 1);
		write_64(&p_afu->p_afu_map->global.fc_regs[i][FC_ERRCAP / 8],
			 0);
	}

	/* sync interrupts for master's IOARRIN write */
	/* note that unlike asyncs, there can be no pending sync interrupts */
	/* at this time (this is a fresh context and master has not written */
	/* IOARRIN yet), so there is nothing to clear. */

	/* set LISN#, it is always sent to the context that wrote IOARRIN */
	write_64(&p_afu->p_host_map->ctx_ctrl, SISL_MSI_SYNC_ERROR);
	write_64(&p_afu->p_host_map->intr_mask, SISL_ISTATUS_MASK);
}

static irqreturn_t cflash_dummy_irq_handler(int irq, void *data)
{
	/* XXX - to be removed once we settle the 4th interrupt */
	cflash_info("returning rc=%d", IRQ_HANDLED);
	return IRQ_HANDLED;
}

static irqreturn_t cflash_sync_err_irq(int irq, void *data)
{
	struct afu *p_afu = (struct afu *)data;
	u64 reg;
	u64 reg_unmasked;

	reg = read_64(&p_afu->p_host_map->intr_status);
	reg_unmasked = (reg & SISL_ISTATUS_UNMASK);

	if (reg_unmasked == 0UL) {
		cflash_err("%llX: spurious interrupt, intr_status %016llX",
			   (u64) p_afu, reg);
		goto cflash_sync_err_irq_exit;
	}

	cflash_err("%llX: unexpected interrupt, intr_status %016llX",
		   (u64) p_afu, reg);

	write_64(&p_afu->p_host_map->intr_clear, reg_unmasked);

cflash_sync_err_irq_exit:
	cflash_info("returning rc=%d", IRQ_HANDLED);
	return IRQ_HANDLED;
}

static irqreturn_t cflash_rrq_irq(int irq, void *data)
{
	struct afu *p_afu = (struct afu *)data;
	struct cflash *p_cflash;
	struct afu_cmd *p_cmd;
	unsigned long lock_flags = 0UL;

       	p_cflash = (struct cflash *) (p_afu - offsetof(struct cflash, p_afu));
	/*
	 * XXX - might want to look at using locals for loop control
	 * as an optimization
	 */

	/* Process however many RRQ entries that are ready */
	while ((*p_afu->p_hrrq_curr & SISL_RESP_HANDLE_T_BIT) == p_afu->toggle) {
		struct scsi_cmnd *scp;

		p_cmd = (struct afu_cmd *)
		    ((*p_afu->p_hrrq_curr) & (~SISL_RESP_HANDLE_T_BIT));

		spin_lock_irqsave(p_cmd->slock, lock_flags);
		p_cmd->sa.host_use_b[0] |= B_DONE;
		spin_unlock_irqrestore(p_cmd->slock, lock_flags);

		/* already stopped if timer fired */
		timer_stop(&p_cmd->timer, FALSE);

		/*
		   hexdump ((void *)&p_cmd->rcb, sizeof(sisl_ioarcb_t), "rcb");
		   hexdump ((void *)&p_cmd->sa, sizeof(sisl_ioasa_t), "sa");
		   hexdump ((void *)p_cmd->rcb.data_ea, 64, "data");
		 */

		if (p_cmd->rcb.rsvd2) {
			scp = (struct scsi_cmnd *)p_cmd->rcb.rsvd2;
			if (p_cmd->sa.rc.afu_rc || p_cmd->sa.rc.scsi_rc ||
			    p_cmd->sa.rc.fc_rc) {
				/* XXX: Needs to be decoded to report errors */
				scp->result = (DID_OK << 16);
			} else {
				scp->result = (DID_OK << 16);
			}
			cflash_info("calling scsi_set_resid, scp=0x%llx len=%d",
				    p_cmd->rcb.rsvd2, p_cmd->sa.resid);

			scsi_set_resid(scp, p_cmd->sa.resid);
			scp->scsi_done(scp);
			scsi_dma_unmap(scp);
			p_cmd->rcb.rsvd2 = 0ULL;
			if (p_cmd->special) {
				p_cflash->tmf_active = 0;
				wake_up_all(&p_cflash->tmf_wait_q);
			}
			cflash_cmd_cin(p_cmd);
		}

		/* Advance to next entry or wrap and flip the toggle bit */
		if (p_afu->p_hrrq_curr < p_afu->p_hrrq_end) {
			p_afu->p_hrrq_curr++;
		} else {
			p_afu->p_hrrq_curr = p_afu->p_hrrq_start;
			p_afu->toggle ^= SISL_RESP_HANDLE_T_BIT;
		}
	}

	/* XXX
	   cflash_info("returning rc=%d", IRQ_HANDLED);
	 */
	return IRQ_HANDLED;
}

static irqreturn_t cflash_async_err_irq(int irq, void *data)
{
	struct afu *p_afu = (struct afu *)data;

	/*
	 * XXX - Matt to work on this next, need to create a thread
	 * as this type of interrupt can drive a link reset which
	 * will block.
	 */

	cflash_info("returning rc=%d, afu=%p", IRQ_HANDLED, p_afu);
	return IRQ_HANDLED;
}

/*
 * Start the afu context.  This is calling into the generic CXL driver code
 * (except for the contents of the WED).
 */
int cflash_start_context(struct cflash *p_cflash)
{
	int rc = 0;

	rc = cxl_start_context(p_cflash->p_mcctx,
			       p_cflash->p_afu->work.work_element_descriptor,
			       NULL);

	cflash_info("returning rc=%d", rc);
	return rc;
}

/*
 * Stop the afu context.  This is calling into the generic CXL driver code
 */
void cflash_stop_context(struct cflash *p_cflash)
{
	cxl_stop_context(p_cflash->p_mcctx);
	cflash_info("returning");
}

#define WWPN_LEN	16
#define WWPN_BUF_LEN	(WWPN_LEN + 1)

int cflash_read_vpd(struct cflash *p_cflash, u64 wwpn[])
{

	char *buf = NULL;
	int rc = 0;
	int bytes = 0;
	bool l_rc;
	int l_kw_length;
	char localwwpn[NUM_FC_PORTS][WWPN_BUF_LEN];

	cflash_info("pci_dev=%p", p_cflash->parent_dev);

	buf = kzalloc(KWDATA_SZ, GFP_KERNEL);
	if (!buf) {
		cflash_err("could not allocate mem");
		rc = -ENOMEM;
		goto out;
	}
	bytes = pci_read_vpd(p_cflash->parent_dev, 0, KWDATA_SZ, buf);
	if (bytes <= 0) {
		cflash_err("could not read VPD rc %d", rc);
		rc = -ENODEV;
		goto out;
	}
	hexdump((void *)buf, KWDATA_SZ, "vpd");

	/* Decode Port 0 */
	l_kw_length = WWPN_LEN;
	l_rc =
	    prov_find_vpd_kw("V5", buf, KWDATA_SZ, (u8 *) & localwwpn[0],
			     &l_kw_length);
	if (l_rc == false) {
		cflash_err("Error: Unable to find Port name VPD for Port 0 "
			   "(VPD KW V5)");
		rc = -ENODEV;
		goto out;
	}

	hexdump((void *)localwwpn[0], WWPN_LEN, "wwpn0");
	/* NULL terminate before calling kstrtoul */
	localwwpn[0][WWPN_BUF_LEN - 1] = '\0';
	rc = kstrtoul(localwwpn[0], WWPN_LEN, (unsigned long *)&wwpn[0]);
	if (rc)
		goto out;

	/* Decode Port 1 */
	l_kw_length = WWPN_LEN;
	l_rc =
	    prov_find_vpd_kw("V6", buf, KWDATA_SZ, (u8 *) & localwwpn[1],
			     &l_kw_length);
	if (l_rc == false) {
		cflash_err("Error: Unable to find Port name VPD for Port 1 "
			   "(VPD KW V6)");
		rc = -ENODEV;
		goto out;
	}

	hexdump((void *)localwwpn[1], WWPN_LEN, "wwpn1");
	/* NULL terminate before calling kstrtoul */
	localwwpn[1][WWPN_BUF_LEN - 1] = '\0';
	rc = kstrtoul(localwwpn[1], WWPN_LEN, (unsigned long *)&wwpn[1]);
	if (rc)
		goto out;

out:
	if (buf)
		kfree(buf);
	cflash_info("returning rc=%d", rc);
	return rc;
}

void cflash_context_reset(struct afu *p_afu)
{
	int nretry = 0;
	u64 rrin = 0x1;

	cflash_info("p_afu=%p", p_afu);

	if (p_afu->room == 0) {
		asm volatile ("eieio"::); /* let IOARRIN writes complete */
		do {
			p_afu->room = read_64(&p_afu->p_host_map->cmd_room);
			udelay(nretry);
		} while ((p_afu->room == 0) && (nretry++ < MC_ROOM_RETRY_CNT));
	}

	if (p_afu->room) {
		write_64(&p_afu->p_host_map->ioarrin, (u64) rrin);
		asm volatile ("eieio"::); /* let IOARRIN writes complete */
		do {
			rrin = read_64(&p_afu->p_host_map->ioarrin);
			/* Double delay each time */
			udelay(2^nretry);
		} while ((rrin == 0x1) && (nretry++ < MC_ROOM_RETRY_CNT));
	}
	else
		cflash_err("no cmd_room to send reset");
}


/**
 * init_pcr - Initialize the Provisioning and Control Registers.
 * @p_cflash:        struct cflash pointer
 *
 * Returns:
 *      NONE
 */
void init_pcr(struct cflash *p_cflash)
{
	struct afu *p_afu = p_cflash->p_afu;
	int i;

	for (i = 0; i < MAX_CONTEXT; i++) {
		p_afu->ctx_info[i].p_ctrl_map =
		    &p_afu->p_afu_map->ctrls[i].ctrl;
		/* disrupt any clients that could be running */
		/* e. g. clients that survived a master restart */
		write_64(&p_afu->ctx_info[i].p_ctrl_map->rht_start, 0);
		write_64(&p_afu->ctx_info[i].p_ctrl_map->rht_cnt_id, 0);
		write_64(&p_afu->ctx_info[i].p_ctrl_map->ctx_cap, 0);
	}

	/* copy frequently used fields into p_afu */
	p_afu->ctx_hndl = (u16) cxl_process_element(p_cflash->p_mcctx);
	/* ctx_hndl is 16 bits in CAIA */
	p_afu->p_host_map = &p_afu->p_afu_map->hosts[p_afu->ctx_hndl].host;
	p_afu->p_ctrl_map = &p_afu->p_afu_map->ctrls[p_afu->ctx_hndl].ctrl;

	/* initialize cmd fields that never change */
	for (i = 0; i < CFLASH_MAX_CMDS; i++) {
		p_afu->cmd[i].rcb.ctx_id = p_afu->ctx_hndl;
		p_afu->cmd[i].rcb.msi = SISL_MSI_RRQ_UPDATED;
		p_afu->cmd[i].rcb.rrq = 0x0;
	}

}

/**
 * init_global - Initialize the AFU Global Registers
 * @p_cflash:        struct cflash pointer
 *
 * Returns:
 *      NONE
 */
int init_global(struct cflash *p_cflash)
{
	struct afu *p_afu = p_cflash->p_afu;
	u64 wwpn[NUM_FC_PORTS];	/* wwpn of AFU ports */
	int i = 0;
	int rc = 0;
	u64 reg;

	rc = cflash_read_vpd(p_cflash, &wwpn[0]);
	if (rc) {
		cflash_err("could not read vpd rc=%d", rc);
		goto out;
	}
	cflash_info("wwpn0=0x%llx wwpn1=0x%llx", wwpn[0], wwpn[1]);

	/* set up RRQ in AFU for master issued cmds */
	write_64(&p_afu->p_host_map->rrq_start, (u64) p_afu->p_hrrq_start);
	write_64(&p_afu->p_host_map->rrq_end, (u64) p_afu->p_hrrq_end);

	/* AFU configuration */
	reg = read_64(&p_afu->p_afu_map->global.regs.afu_config);
	reg |= 0x7F20; /* enable all auto retry options and LE */
	/* leave others at default: */
	/* CTX_CAP write protected, mbox_r does not clear on read and */
	/* checker on if dual afu */
	write_64(&p_afu->p_afu_map->global.regs.afu_config, reg);

	/* global port select: select either port */
#if 0   /* XXX - check with Andy/Todd b/c this doesn't work */
	if (internal_lun)
		write_64(&p_afu->p_afu_map->global.regs.afu_port_sel, 0x1);
	else
#endif
		write_64(&p_afu->p_afu_map->global.regs.afu_port_sel, 0x3);

	for (i = 0; i < NUM_FC_PORTS; i++) {
		/* unmask all errors (but they are still masked at AFU) */
		write_64(&p_afu->p_afu_map->global.fc_regs[i][FC_ERRMSK / 8],
			 0);
		/* clear CRC error cnt & set a threshold */
		(void)read_64(&p_afu->p_afu_map->
			      global.fc_regs[i][FC_CNT_CRCERR / 8]);
		write_64(&p_afu->p_afu_map->global.fc_regs[i]
			 [FC_CRC_THRESH / 8], MC_CRC_THRESH);

		/* set WWPNs. If already programmed, wwpn[i] is 0 */
		if (wwpn[i] != 0 &&
		    afu_set_wwpn(p_afu, i,
				 &p_afu->p_afu_map->global.fc_regs[i][0],
				 wwpn[i])) {
			cflash_dbg("failed to set WWPN on port %d", i);
			rc = -EIO;
			goto out;
		}

	}

	/* set up master's own CTX_CAP to allow real mode, host translation */
	/* tbls, afu cmds and read/write GSCSI cmds. */
	/* First, unlock ctx_cap write by reading mbox */
	(void)read_64(&p_afu->p_ctrl_map->mbox_r);	/* unlock ctx_cap */
	asm volatile ("eieio"::);
	write_64(&p_afu->p_ctrl_map->ctx_cap,
		 SISL_CTX_CAP_REAL_MODE | SISL_CTX_CAP_HOST_XLATE |
		 SISL_CTX_CAP_READ_CMD | SISL_CTX_CAP_WRITE_CMD |
		 SISL_CTX_CAP_AFU_CMD | SISL_CTX_CAP_GSCSI_CMD);
	/* init heartbeat */
	p_afu->hb = read_64(&p_afu->p_afu_map->global.regs.afu_hb);

out:
	return rc;
}

int cflash_start_afu(struct cflash *p_cflash)
{
	struct afu *p_afu = p_cflash->p_afu;

	int i = 0;
	int rc = 0;

	for (i = 0; i < MAX_CONTEXT; i++) {
		p_afu->rht_info[i].rht_start = &p_afu->rht[i][0];
	}

	for (i = 0; i < CFLASH_MAX_CMDS; i++) {
		struct timer_list *p_timer = &p_afu->cmd[i].timer;

		init_timer(p_timer);
		p_timer->data = (unsigned long)p_afu;
		p_timer->function = (void (*)(unsigned long))cflash_context_reset;

		spin_lock_init(&p_afu->cmd[i]._slock);
		p_afu->cmd[i].slock = &p_afu->cmd[i]._slock;
	}
	init_pcr(p_cflash);

	/* initialize RRQ pointers */
	p_afu->p_hrrq_start = &p_afu->rrq_entry[0];
	p_afu->p_hrrq_end = &p_afu->rrq_entry[NUM_RRQ_ENTRY - 1];
	p_afu->p_hrrq_curr = p_afu->p_hrrq_start;
	p_afu->toggle = 1;

	rc = init_global(p_cflash);

	cflash_info("returning rc=%d", rc);
	return rc;
}

void cflash_term_mc(struct cflash *p_cflash, enum undo_level level)
{
	struct afu *p_afu = p_cflash->p_afu;

	if ((p_afu == NULL) || (p_cflash->p_mcctx == NULL))
	{
		cflash_info("returning from term_mc with NULL afu or MC");
		return;
	}


	switch (level) { 
	case UNDO_START:
		cflash_stop_context(p_cflash);
	case UNMAP_FOUR:
		cflash_info("before unmap 4");
		cxl_unmap_afu_irq(p_cflash->p_mcctx, 4, p_afu);
	case UNMAP_THREE:
		cflash_info("before unmap 3");
		cxl_unmap_afu_irq(p_cflash->p_mcctx, 3, p_afu);
	case UNMAP_TWO:
		cflash_info("before unmap 2");
		cxl_unmap_afu_irq(p_cflash->p_mcctx, 2, p_afu);
	case UNMAP_ONE:
		cflash_info("before unmap 1");
		cxl_unmap_afu_irq(p_cflash->p_mcctx, 1, p_afu);
	case FREE_IRQ:
		cflash_info("before cxl_free_afu_irqs");
		cxl_free_afu_irqs(p_cflash->p_mcctx);
		cflash_info("before cxl_release_context");
	case RELEASE_CONTEXT:
		cxl_release_context(p_cflash->p_mcctx);
		p_cflash->p_mcctx = NULL;
	}
}

int cflash_init_mc(struct cflash *p_cflash)
{
	struct cxl_context *ctx;
	struct device *dev = &p_cflash->p_dev->dev;
	struct afu *p_afu = p_cflash->p_afu;
	int rc = 0;
	enum undo_level level;

	ctx = cxl_dev_context_init(p_cflash->p_dev);
	if (!ctx)
		return -ENOMEM;
	p_cflash->p_mcctx = ctx;

	/* Set it up as a master with the CXL */
	cxl_set_master(ctx);

	/* Allocate AFU generated interrupt handler */
	rc = cxl_allocate_afu_irqs(ctx, 4);
	if (rc) {
		cflash_dev_err(dev, "call to allocate_afu_irqs failed rc=%d!",
			       rc);
		level =  RELEASE_CONTEXT;
		goto out;
	}

	/* Register AFU interrupt 1 (SISL_MSI_SYNC_ERROR) */
	rc = cxl_map_afu_irq(ctx, 1, cflash_sync_err_irq, p_afu,
			     "SISL_MSI_SYNC_ERROR");
	if (!rc) {
		cflash_dev_err(dev,
			       "IRQ 1 (SISL_MSI_SYNC_ERROR) map failed!");
		level =  FREE_IRQ;
		goto out;
	}
	/* Register AFU interrupt 2 (SISL_MSI_RRQ_UPDATED) */
	rc = cxl_map_afu_irq(ctx, 2, cflash_rrq_irq, p_afu,
			     "SISL_MSI_RRQ_UPDATED");
	if (!rc) {
		cflash_dev_err(dev,
			       "IRQ 2 (SISL_MSI_RRQ_UPDATED) map failed!");
		level = UNMAP_ONE;
		goto out;
	}
	/* Register AFU interrupt 3 (SISL_MSI_ASYNC_ERROR) */
	rc = cxl_map_afu_irq(ctx, 3, cflash_async_err_irq, p_afu,
			     "SISL_MSI_ASYNC_ERROR");
	if (!rc) {
		cflash_dev_err(dev,
			       "IRQ 3 (SISL_MSI_ASYNC_ERROR) map failed!");
		level = UNMAP_TWO;
		goto out;
	}

	/*
	 * XXX - why did we put a 4th interrupt? Were we thinking this is
	 * for the SISL_MSI_PSL_XLATE? Wouldn't that be covered under the
	 * cxl_register_error_irq() ?
	 */

	/* Register AFU interrupt 4 for errors. */
	rc = cxl_map_afu_irq(ctx, 4, cflash_dummy_irq_handler, p_afu, "err3");
	if (!rc) {
		cflash_dev_err(dev, "IRQ 4 map failed!");
		level = UNMAP_THREE;
		goto out;
	}
	rc = 0;

	/* Register for PSL errors. TODO: implement this */
	/* cxl_register_error_irq(dev,... ,callback function, private data); */

	/* This performs the equivalent of the CXL_IOCTL_START_WORK.
	 * The CXL_IOCTL_GET_PROCESS_ELEMENT is implicit in the process
	 * element (pe) that is embedded in the context (ctx)
	 */
	cflash_start_context(p_cflash);
ret:
	cflash_info("returning rc=%d", rc);
	return rc;
out:
	cflash_term_mc(p_cflash, level);
	goto ret;
}


int cflash_init_afu(struct cflash *p_cflash)
{
	u64 reg;
	int rc = 0;
	struct afu *p_afu = p_cflash->p_afu;
	struct device *dev = &p_cflash->p_dev->dev;

	rc = cflash_init_mc(p_cflash);
	if (rc) {
		cflash_dev_err(dev, "call to init_mc failed, rc=%d!", rc);
		goto err1;
	}

	INIT_LIST_HEAD(&p_afu->luns);

	/* Map the entire MMIO space of the AFU.
	 */
	p_afu->p_afu_map = cxl_psa_map(p_cflash->p_mcctx);
	if (!p_afu->p_afu_map) {
		rc = -ENOMEM;
		cflash_term_mc(p_cflash, UNDO_START);
		cflash_dev_err(dev, "call to cxl_psa_map failed!");
		goto err1;
	}


	/* don't byte reverse on reading afu_version, else the string form */
	/*     will be backwards */
	reg = p_afu->p_afu_map->global.regs.afu_version;
	memcpy(p_afu->version, &reg, 8);
	p_afu->interface_version = read_64(&p_afu->p_afu_map->
					   global.regs.interface_version);
	cflash_info("afu version %s, interface version 0x%llx", 
		    p_afu->version, p_afu->interface_version);

	rc = cflash_start_afu(p_cflash);
	if (rc) {
		cflash_dev_err(dev, "call to start_afu failed, rc=%d!", rc);
		cflash_term_mc(p_cflash, UNDO_START);
		cxl_psa_unmap((void *)p_afu->p_afu_map);
		p_afu->p_afu_map = NULL;
	}

err1:
	cflash_info("returning rc=%d", rc);
	return rc;
}

void cflash_term_afu(struct cflash *p_cflash)
{
	struct afu *p_afu = p_cflash->p_afu;
	struct lun_info *p_lun_info, *p_temp;

	cflash_term_mc(p_cflash, UNDO_START);

	/* Need to stop timers before unmapping */
	if (p_cflash->p_afu) {
		cflash_stop_afu(p_cflash);

		list_for_each_entry_safe(p_lun_info, p_temp, &p_afu->luns,
					 list) {
			list_del(&p_lun_info->list);
			ba_terminate(&p_lun_info->blka.ba_lun);
			kfree(p_lun_info);
		}
	}

	cflash_info("returning");
}

/* do we need to retry AFU_CMDs (sync) on afu_rc = 0x30 ? */
/* can we not avoid that ? */
/* not retrying afu timeouts (B_TIMEOUT) */
/* returns 1 if the cmd should be retried, 0 otherwise */
/* sets B_ERROR flag based on IOASA */
int check_status(struct sisl_ioasa_s *p_ioasa)
{
	if (p_ioasa->ioasc == 0) {
		return 0;
	}

	p_ioasa->host_use_b[0] |= B_ERROR;

	if (!(p_ioasa->host_use_b[1]++ < MC_RETRY_CNT)) {
		return 0;
	}

	switch (p_ioasa->rc.afu_rc) {
	case SISL_AFU_RC_NO_CHANNELS:
	case SISL_AFU_RC_OUT_OF_DATA_BUFS:
		msleep(1);	/* 1 msec */
		return 1;

	case 0:
		/* no afu_rc, but either scsi_rc and/or fc_rc is set */
		/* retry all scsi_rc and fc_rc after a small delay */
		msleep(1);	/* 1 msec */
		return 1;
	}

	return 0;
}

void cflash_send_cmd(struct afu *p_afu, struct afu_cmd *p_cmd)
{
	int nretry = 0;

	if (p_afu->room == 0) {
		asm volatile ("eieio"::); /* let IOARRIN writes complete */
		do {
			p_afu->room = read_64(&p_afu->p_host_map->cmd_room);
			udelay(nretry);
		} while ((p_afu->room == 0) && (nretry++ < MC_ROOM_RETRY_CNT));
	}

	p_cmd->sa.host_use_b[0] = 0;	/* 0 means active */
	p_cmd->sa.ioasc = 0;

	/* make memory updates visible to AFU before MMIO */
	asm volatile ("lwsync"::);

	/*
	 * XXX - find out why this code originally (and still does)
	 * have a doubler (*2) for the timeout value
	 */
	timer_start(&p_cmd->timer, (p_cmd->rcb.timeout * 2 * HZ));

	/* Write IOARRIN */
	if (p_afu->room)
		write_64(&p_afu->p_host_map->ioarrin, (u64) & p_cmd->rcb);
	else
		cflash_err("no cmd_room to send 0x%X", p_cmd->rcb.cdb[0]);

	cflash_dbg("p_cmd=%p len=%d ea=%p", p_cmd, p_cmd->rcb.data_len,
		    (void *)p_cmd->rcb.data_ea);

	/* Let timer fire to complete the response... */
}

void cflash_wait_resp(struct afu *p_afu, struct afu_cmd *p_cmd)
{
	unsigned long lock_flags = 0;

	spin_lock_irqsave(p_cmd->slock, lock_flags);
	while (!(p_cmd->sa.host_use_b[0] & B_DONE)) {

		/*
		 * XXX - how do we want to handle this...
		 * need to study how send_cmd/wait_resp
		 * is used in interrupt context.
		 */

		spin_unlock_irqrestore(p_cmd->slock, lock_flags);
		udelay(10);
		spin_lock_irqsave(p_cmd->slock, lock_flags);
	}
	spin_unlock_irqrestore(p_cmd->slock, lock_flags);

	timer_stop(&p_cmd->timer, FALSE); /* already stopped if timer fired */

	if (p_cmd->sa.ioasc != 0)
		cflash_err("CMD 0x%x failed, IOASC: flags 0x%x, afu_rc 0x%x, "
			   "scsi_rc 0x%x, fc_rc 0x%x",
			   p_cmd->rcb.cdb[0],
			   p_cmd->sa.rc.flags,
			   p_cmd->sa.rc.afu_rc,
			   p_cmd->sa.rc.scsi_rc, p_cmd->sa.rc.fc_rc);
}

void timer_start(struct timer_list *p_timer, unsigned long timeout_in_jiffies)
{
	p_timer->expires = (jiffies + timeout_in_jiffies);
	add_timer(p_timer);
}

void timer_stop(struct timer_list *p_timer, bool sync)
{
	if (unlikely(sync))
		del_timer_sync(p_timer);
	else
		del_timer(p_timer);
}

/*
 * afu_sync can be called from interrupt thread and the main processing
 * thread. Caller is responsible for any serialization.
 * Also, it can be called even before/during discovery, so we must use
 * a dedicated cmd not used by discovery.
 *
 * AFU takes only 1 sync cmd at a time.
 */
int afu_sync(struct afu *p_afu,
	     ctx_hndl_t ctx_hndl_u, res_hndl_t res_hndl_u, u8 mode)
{
	u16 *p_u16;
	u32 *p_u32;
	struct afu_cmd *p_cmd = &p_afu->cmd[AFU_SYNC_INDEX];
	int rc = 0;

	cflash_info("p_afu=%p p_cmd=%p %d", p_afu, p_cmd, ctx_hndl_u);

	memset(p_cmd->rcb.cdb, 0, sizeof(p_cmd->rcb.cdb));

	p_cmd->rcb.req_flags = SISL_REQ_FLAGS_AFU_CMD;
	p_cmd->rcb.port_sel = 0x0;	/* NA */
	p_cmd->rcb.lun_id = 0x0;	/* NA */
	p_cmd->rcb.data_len = 0x0;
	p_cmd->rcb.data_ea = 0x0;
	p_cmd->rcb.timeout = MC_AFU_SYNC_TIMEOUT;

	p_cmd->rcb.cdb[0] = 0xC0;	/* AFU Sync */
	p_cmd->rcb.cdb[1] = mode;
	p_u16 = (u16 *) & p_cmd->rcb.cdb[2];
	write_16(p_u16, ctx_hndl_u);	/* context to sync up */
	p_u32 = (u32 *) & p_cmd->rcb.cdb[4];
	write_32(p_u32, res_hndl_u);	/* res_hndl to sync up */

	cflash_send_cmd(p_afu, p_cmd);
	cflash_wait_resp(p_afu, p_cmd);

	if ((p_cmd->sa.ioasc != 0) || (p_cmd->sa.host_use_b[0] & B_ERROR)) {
		rc = -1;
		/* B_ERROR is set on timeout */
	}

	cflash_info("returning rc=%d", rc);
	return rc;
}
int cflash_send_scsi(struct afu *p_afu, struct scsi_cmnd *scp)
{
	struct afu_cmd *p_cmd;

	u64 port_sel = scp->device->channel + 1;
	int nseg, i, ncount;
	struct scatterlist *sg;
	short lflag = 0;
	int rc = 0;

	unsigned long lock_flags = 0;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;

	spin_lock_irqsave(host->host_lock, lock_flags);
	while (p_cflash->tmf_active) {
		spin_unlock_irqrestore(host->host_lock, lock_flags);
		wait_event(p_cflash->tmf_wait_q, !p_cflash->tmf_active);
		spin_lock_irqsave(host->host_lock, lock_flags);
	}
	spin_unlock_irqrestore(host->host_lock, lock_flags);

	p_cmd = cflash_cmd_cout(p_afu);
	if (!p_cmd) {
		cflash_err("could not get a free command");
		rc = SCSI_MLQUEUE_HOST_BUSY;
		goto out;
	}

	p_cmd->rcb.ctx_id = p_afu->ctx_hndl;
	p_cmd->rcb.port_sel = port_sel;
	p_cmd->rcb.lun_id = lun_to_lunid(scp->device->lun);

	if (scp->sc_data_direction == DMA_TO_DEVICE)
		lflag = SISL_REQ_FLAGS_HOST_WRITE;
	else
		lflag = SISL_REQ_FLAGS_HOST_READ;

	p_cmd->rcb.req_flags = (SISL_REQ_FLAGS_PORT_LUN_ID |
				SISL_REQ_FLAGS_SUP_UNDERRUN | lflag);
	p_cmd->rcb.timeout = MC_DISCOVERY_TIMEOUT;

	/* Stash the scp in the reserved field, for reuse during interrupt */
	p_cmd->rcb.rsvd2 = (u64) scp;

	p_cmd->sa.host_use_b[1] = 0;	/* reset retry cnt */

	nseg = scsi_dma_map(scp);
	ncount = scsi_sg_count(scp);
	scsi_for_each_sg(scp, sg, ncount, i) {
		p_cmd->rcb.data_len = (sg_dma_len(sg));
                p_cmd->rcb.data_ea = (sg_dma_address(sg));
		//p_cmd->rcb.data_len = (sg_dma_len(sg) & SISLITE_LEN_MASK);
		//p_cmd->rcb.data_ea = (sg_phys(sg));
	}

	/* Copy the CDB from the scsi_cmnd passed in */
	memcpy(p_cmd->rcb.cdb, scp->cmnd, sizeof(p_cmd->rcb.cdb));

	/* Send the command */
	cflash_send_cmd(p_afu, p_cmd);

out:
	return rc;
}

int cflash_send_tmf(struct afu *p_afu, struct scsi_cmnd *scp, u64 cmd)
{
	struct afu_cmd *p_cmd;

	u64 port_sel = scp->device->channel + 1;
	short lflag = 0;
	unsigned long lock_flags = 0;
	struct Scsi_Host *host = scp->device->host;
	struct cflash *p_cflash = (struct cflash *)host->hostdata;
	int rc = 0;

	spin_lock_irqsave(host->host_lock, lock_flags);
	while (p_cflash->tmf_active) {
		spin_unlock_irqrestore(host->host_lock, lock_flags);
		wait_event(p_cflash->tmf_wait_q, !p_cflash->tmf_active);
		spin_lock_irqsave(host->host_lock, lock_flags);
	}
	spin_unlock_irqrestore(host->host_lock, lock_flags);

	p_cmd = cflash_cmd_cout(p_afu);
	if (!p_cmd) {
		cflash_err("could not get a free command");
		rc = SCSI_MLQUEUE_HOST_BUSY;
		goto out;
	}

	p_cmd->rcb.ctx_id = p_afu->ctx_hndl;
	p_cmd->rcb.port_sel = port_sel;
	p_cmd->rcb.lun_id = lun_to_lunid(scp->device->lun);

	lflag = SISL_REQ_FLAGS_TMF_CMD;

	p_cmd->rcb.req_flags = (SISL_REQ_FLAGS_PORT_LUN_ID |
				SISL_REQ_FLAGS_SUP_UNDERRUN | lflag);
	p_cmd->rcb.timeout = MC_DISCOVERY_TIMEOUT;

	/* Stash the scp in the reserved field, for reuse during interrupt */
	p_cmd->rcb.rsvd2 = (u64) scp;
	p_cmd->special = 0x1;
	p_cflash->tmf_active = 0x1;

	p_cmd->sa.host_use_b[1] = 0;	/* reset retry cnt */

	/* Copy the CDB from the cmd passed in */
	memcpy(p_cmd->rcb.cdb, &cmd, sizeof(cmd));

	/* Send the command */
	cflash_send_cmd(p_afu, p_cmd);

out:
	return rc;

}
/**
 * cflash_probe - Adapter hot plug add entry point
 *
 * Return value:
 *      0 on success / non-zero on failure
 **/
static int cflash_probe(struct pci_dev *pdev,
			const struct pci_device_id *dev_id)
{
	struct Scsi_Host *host;
	struct cflash *p_cflash = NULL;
	struct device *phys_dev;
	int rc = 0;

	cflash_dev_dbg(&pdev->dev, "Found CFLASH with IRQ: %d", pdev->irq);

	if (fullqc)
		driver_template.scan_finished = NULL;

	host = scsi_host_alloc(&driver_template, sizeof(struct cflash));
	if (!host) {
		cflash_dev_err(&pdev->dev, "call to scsi_host_alloc failed!");
		rc = -ENOMEM;
		goto out;
	}
	/* XXX: Need to double check with the sislite spec */
	host->max_id = CFLASH_MAX_NUM_TARGETS_PER_BUS;
	host->max_lun = CFLASH_MAX_NUM_LUNS_PER_TARGET;
	host->max_channel = NUM_FC_PORTS-1;
	host->unique_id = host->host_no;
	host->max_cmd_len = CFLASH_MAX_CDB_LEN;

	p_cflash = (struct cflash *)host->hostdata;
	p_cflash->host = host;
	rc = cflash_gb_alloc(p_cflash);
	if (rc) {
		cflash_dev_err(&pdev->dev, "call to scsi_host_alloc failed!");
		rc = -ENOMEM;
		goto out;
	}

	p_cflash->p_dev = pdev;
	p_cflash->last_lun_index = 0;
	p_cflash->task_set = 0;
	p_cflash->p_dev_id = (struct pci_device_id *)dev_id;
	p_cflash->tmf_active = 0;
	p_cflash->p_mcctx = NULL;
	p_cflash->context_reset_active = 0;
        init_waitqueue_head(&p_cflash->tmf_wait_q);

	pci_set_drvdata(pdev, p_cflash);

	/* Use the special service provided to look up the physical
	 * PCI device, since we are called on the probe of the virtual
	 * PCI host bus (vphb)
	 */
	phys_dev = cxl_get_phys_dev(pdev);
	if (!dev_is_pci(phys_dev)) {	/* make sure it's pci */
		cflash_err("not a pci dev");
		rc = ENODEV;
		goto out_remove;
	}
	p_cflash->parent_dev = to_pci_dev(phys_dev);

	p_cflash->afu = cxl_pci_to_afu(pdev, NULL);
	rc = cflash_init_afu(p_cflash);
	if (rc) {
		cflash_dev_err(&pdev->dev,
			       "call to cflash_init_afu failed rc=%d!", rc);
		goto out_remove;
	}

	/* XXX: Add threads for afu_rrq_rx and afu_err_rx */
	/* after creating afu_err_rx thread, unmask error interrupts */
	afu_err_intr_init(p_cflash->p_afu);

	rc = cflash_init_pci(p_cflash);
	if (rc) {
		cflash_dev_err(&pdev->dev,
			       "call to cflash_init_pci failed rc=%d!", rc);
		goto out_remove;
	}

	rc = cflash_init_scsi(p_cflash);
	if (rc) {
		cflash_dev_err(&pdev->dev,
			"call to cflash_init_scsi failed rc=%d!", rc);
		goto out_remove;
	}

out:
	cflash_info("returning rc=%d", rc);
	return rc;

out_remove:
	cflash_remove(pdev);
	goto out;
}

/**
 * cflash_shutdown - Shutdown handler.
 * @pdev:       pci device struct
 *
 * This function is invoked upon system shutdown/reboot. It will issue
 * an adapter shutdown to the adapter to flush the write cache.
 *
 * Return value:
 *      none
 **/
static void cflash_shutdown(struct pci_dev *pdev)
{
	/* XXX: Dummy */
	struct cflash *p_cflash = pci_get_drvdata(pdev);
	struct Scsi_Host *host = p_cflash->host;
	unsigned long lock_flags = 0;

	spin_lock_irqsave(host->host_lock, lock_flags);
	while (p_cflash->tmf_active) {
		spin_unlock_irqrestore(host->host_lock, lock_flags);
		wait_event(p_cflash->tmf_wait_q, !p_cflash->tmf_active);
		spin_lock_irqsave(host->host_lock, lock_flags);
	}
	spin_unlock_irqrestore(host->host_lock, lock_flags);

}

/**
 * cflash_pci_error_detected - Called when a PCI error is detected.
 * @pdev:       PCI device struct
 * @state:      PCI channel state
 *
 * Description: Called when a PCI error is detected.
 *
 * Return value:
 *      PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT
 */
static pci_ers_result_t cflash_pci_error_detected(struct pci_dev *pdev,
						  pci_channel_state_t state)
{
	switch (state) {
	case pci_channel_io_frozen:
		/* XXX: Dummy */
		return PCI_ERS_RESULT_CAN_RECOVER;
	case pci_channel_io_perm_failure:
		/* XXX: Dummy */
		return PCI_ERS_RESULT_DISCONNECT;
		break;
	default:
		break;
	}
	return PCI_ERS_RESULT_NEED_RESET;
}

/**
 * cflash_pci_mmio_enabled - Called when MMIO has been re-enabled
 * @pdev:       PCI device struct
 *
 * Description: This routine is called to tell us that the MMIO
 * access to the CFLASH has been restored
 */
static pci_ers_result_t cflash_pci_mmio_enabled(struct pci_dev *pdev)
{
	/* XXX: Dummy */
	return PCI_ERS_RESULT_NEED_RESET;
}

/**
 * cflash_pci_slot_reset - Called when PCI slot has been reset.
 * @pdev:       PCI device struct
 *
 * Description: This routine is called by the pci error recovery
 * code after the PCI slot has been reset, just before we
 * should resume normal operations.
 */
static pci_ers_result_t cflash_pci_slot_reset(struct pci_dev *pdev)
{
	/* XXX: Dummy */
	return PCI_ERS_RESULT_RECOVERED;
}

static const struct pci_error_handlers cflash_err_handler = {
	.error_detected = cflash_pci_error_detected,
	.mmio_enabled = cflash_pci_mmio_enabled,
	.slot_reset = cflash_pci_slot_reset,
};

static struct pci_driver cflash_driver = {
	.name = CFLASH_NAME,
	.id_table = cflash_pci_table,
	.probe = cflash_probe,
	.remove = cflash_remove,
	.shutdown = cflash_shutdown,
	.err_handler = &cflash_err_handler,
};

/**
 * cflash_halt - Issue shutdown prepare to all adapters
 *
 * Return value:
 *      NOTIFY_OK on success / NOTIFY_DONE on failure
 **/
static int cflash_halt(struct notifier_block *nb, ulong event, void *buf)
{
	/* XXX: Dummy */
	return NOTIFY_OK;
}

static struct notifier_block cflash_notifier = {
	cflash_halt, NULL, 0
};

static int __init init_cflash(void)
{
	cflash_info("IBM Power CAPI Flash Adapter version: %s %s",
		    CFLASH_DRIVER_VERSION, CFLASH_DRIVER_DATE);

	/* Validate module parameters */
	if (internal_lun > 4) {
		cflash_err("Invalid lun_mode parameter! (%d > 4)",
			   internal_lun);
		return(-EINVAL);
	}
	if (cflash_debug > 1) {
		cflash_err("Invalid debug parameter! (%d > 1)",
			   cflash_debug);
		return(-EINVAL);
	}

	register_reboot_notifier(&cflash_notifier);
	return pci_register_driver(&cflash_driver);
}

static void exit_cflash(void)
{
	unregister_reboot_notifier(&cflash_notifier);
	pci_unregister_driver(&cflash_driver);
}

module_init(init_cflash);
module_exit(exit_cflash);
