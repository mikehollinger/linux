Coherent Accelerator Interface (CXL)
====================================

Introduction
============

    The coherent accelerator interface is designed to allow the
    coherent connection of FPGA based accelerators to a POWER system
    using a standard PCIe bus.

    Accelerator functional units (AFUs) are used to implement specific
    functionality behind the POWER service layer (PSL) which among
    other things provides memory address translation services to allow
    each AFU direct access to userspace memory.

    Each AFU may also support multiple contexts to allow multiple
    userspace processes to utilise the accelerator at the same time.

    IBM refers to this as Coherent Accelerator Processor Interface or
    CAPI.  In the kernel it's referred to by the name CXL to avoid
    confusion with the ISDN CAPI.

Hardware overview
=================

          POWER8               FPGA
       +----------+        +---------+
       |          |        |         |
       |   CPU    |        |   AFU   |
       |          |        |         |
       |          |        |         |
       |          |        |         |
       +----------+        +---------+
       |          |        |         |
       |   CAPP   +--------+   PSL   |
       |          |  PCIe  |         |
       +----------+        +---------+

    The POWER8 chip has a CAPP unit which is part of the PHB.  This is
    managed by Linux by calls into OPAL.  Linux doesn't directly
    program the CAPP.

    The FPGA (or coherently attached device) consists of two parts.
    The POWER Service Layer (PSL) and the Accelerator Function unit
    (AFU).

    The AFU is the core part of the accelerator (ie. the compression,
    crypto etc function you want is in here).  The kernel has no
    knowledge of the function of the AFU.  Only userspace interacts
    directly with the AFU.

    The PSL provides the translation (IOMMU) and interrupt services
    that the AFU needs.  This is what the kernel interacts.  For
    example, if the AFU needs to read a particular virtual address, it
    sends that address to the PSL, it then translates it, fetches the
    data from memory and returns it to the AFU.  If the PSL has a
    translation miss, it interrupts the kernel and the kernel services
    the fault.  The context to which this fault is serviced is based
    on who owns that acceleration function.

AFU Models
==========

    There are two models supported by the AFU.  dedicated and AFU
    directed.  AFU may support one or both models.

    In dedicated model only one MMU context is supported.  In this
    model, only one userspace process can use the accelerator at time.

    In AFU directed model, up to 16K simultaneous contexts can be
    supported.  This means up to 16K simultaneous userspace
    applications may use the accelerator (although AFUs are able to
    allow less).  In this mode, the AFU sends a 16 bit context ID with
    each of it's requests.  This tells the PSL which context is
    associated with this operation.  If the PSL can't translate a
    request, the ID can also be accessed by the kernel so it can
    determine the associated userspace context to services this
    translation with.

MMIO space
==========

    A portion of the FPGA MMIO space can be directly mapped from the
    AFU to userspace.  Either the whole space can be mapped (master
    context), or just a per context portion (slave context).  The
    hardware is self describing, hence the kernel can determine the
    offset and size of the per context portion.

Interrupts
==========

    Data storage and error interrupts are handled by the kernel driver.

    AFUs may generate interrupts that are destined userspace.  These
    are received by the kernel as hardware interrupts and passed onto
    userspace.

Work Element Descriptor (WED)
=============================

    The WED is a 64bit par meter passed to the AFU when a context is
    started.  It's format is upto the AFU hence the kernel has no
    knowledge of what it represents.  Typically it will be a virtual
    address pointer to a work queue where the AFU and userspace can
    share control and status information.


User API
========

    Theq driver will create two character device per AFU
    under /dev/cxl.  One for master and one for slave contexts.

    The master context (eg. /dev/cxl/afu0.0m), has access to all of
    the MMIO space that an AFU provides.  The slave context
    (eg. /dev/cxl/afu0.0m) has access to only the per process MMIO
    space an AFU provides (AFU directed only).

    The following file operations are supported on both slave and
    master devices:

    open

	Opens device and allocates a file descriptor to be used with
	the rest of the API

    ioctl

	CAPI_IOCTL_START_WORK:
            Starts the AFU. Takes a pointer to a struct cxl_ioctl_start_work
		    struct cxl_ioctl_start_work {
			    __u64 wed;
			    __u64 amr;
			    __u64 reserved1;
			    __u32 reserved2;
			    __s16 num_interrupts;
			    __u16 process_element;
			    __u64 reserved3;
			    __u64 reserved4;
			    __u64 reserved5;
			    __u64 reserved6;
		    };

                wed:
                    64bit argument defined by the AFU.  Typically this
		    is an effective address pointing to an AFU
		    specific structure describing what work to
		    perform.

		amr:
                    Authority Mask Register (AMR), same as the powerpc AMR.

		num_interrupt:
		    Number of userspace interrupts to request.  The
		    minimum required for this AFU is given in the
		    sysfs irqs_min file.  -1 will allocate this
		    minimum.  The max is irqs_max (provided no other
		    contexts are running)

		process_element:
		    Written by the kernel with the context id (AKA
		    process element) it allocates.  Slave contexts may
		    want to communicate this to a master process.

		reserved fields:
		    For ABI padding and future extensions

	CAPI_IOCTL_CHECK_ERROR:
            This checks to see if the AFU has encountered an error and
            if so resets it.  If userspace is accessing MMIO space, it
            may notice an EEH fence (all ones on read) before the kernel
            does, hence it needs to inform the kernel of this.

	CAPI_IOCTL_LOAD_AFU_IMAGE:
	    Future work: to dynamically load AFU FPGA images.  Without
	    this, the AFU is assumed to be pre-loaded on the card

    mmap

	Allows access to the per-context AFU MMIO space. An AFU may
	have a memory mapped IO space to facilitate communication with
	the AFU. The size and contents of this area are specific to
	the particular AFU.  The size can be discovered via sysfs.  A
	read of all ones indicates the AFU has encountered an error
	and CAPI_IOCTL_CHECK_ERROR should be called to recover the
	AFU.

	Master contexts will get all of the MMIO space.  Slave
	contexts will get only the per process space associated with
	it's context id.

	This mmap call must be done after the IOCTL is started.

	Care should be taken when accessing MMIO space.  Only 32 and
	64bit accesses are supported by the hardware.  

        Also, the AFU will be designed with a specific endian, so all
	MMIO access should consider endian (recommend endian(3)
	variants like: le64toh(), be64toh() etc).  The same applies to
	shared queues which the WED accesses.

    read

	Reads an event and its associated data from the AFU. Will
	return -EINVAL if the buffer does not contain enough space to
	write the struct capi_event_header. Blocks if no events are
	pending. 

	Will return -EIO in the case of an unrecoverable error or if
	the card is removed.

	All events will return a struct cxl_event which is always the
	same size.  A struct cxl_event_header at the start gives:
		struct cxl_event_header {
			__u32 type;
			__u16 size;
			__u16 process_element;
			__u64 reserved1;
			__u64 reserved2;
			__u64 reserved3;
		};

            type:
	        This gives the type of the interrupt.  This gives how
	        the rest event will be structured structure.  It can
	        be either, AFU interrupt, data storage fault or AFU
	        error.

	    size:
	        This is always sizeof(struct cxl_event)

            process_element:
                Process element (ie context id) of the event.
                Currently this will be only the current context.
                Future work may allow interrupts from one contexts to
                be routed to another (say a master contexts handling
                error interrupts for a slave).
	
	If an AFU interrupt event is received, the full structure received is:
		struct cxl_event_afu_interrupt {
			struct cxl_event_header header;
			__u16 irq;
			__u16 reserved1;
			__u32 reserved2;
			__u64 reserved3;
			__u64 reserved4;
			__u64 reserved5;
		};
            irq:
	        The IRQ number sent by the AFU.

	If an data storage event is received, the full structure received is:
		struct cxl_event_data_storage {
			struct cxl_event_header header;
			__u64 addr;
			__u64 reserved1;
			__u64 reserved2;
			__u64 reserved3;
		};
            address:
	        Address of the data storage trying to be access by the
                AFU.  Valid accesses will handled transparently by the
                kernel but invalid access will generate this event.

	If an afu error event is received, the full structure received is:
		struct cxl_event_afu_error {
			struct cxl_event_header header;
			__u64 err;
			__u64 reserved1;
			__u64 reserved2;
			__u64 reserved3;
		};
            err:
	        Error status from the AFU.  AFU defined.

Sysfs Class
===========

    A cxl sysfs class is added under /sys/class/cxl to facilitate
    enumeration and tuning of the accelerators. It's layout is
    described in Documentation/ABI/testing/sysfs-class-cxl
