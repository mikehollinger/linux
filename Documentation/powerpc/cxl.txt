Coherent Accelerator Interface (CXL)
====================================

Introduction
============

    The coherent accelerator interface is designed to allow the
    coherent connection of FPGA based accelerators (and other devices)
    to a POWER system.  These devices need to adhere to the Coherent
    Accelerator Interface Architecture (CAIA).

    IBM refers to this as the Coherent Accelerator Processor Interface
    or CAPI.  In the kernel it's referred to by the name CXL to avoid
    confusion with the ISDN CAPI subsystem.

Hardware overview
=================

          POWER8               FPGA
       +----------+        +---------+
       |          |        |         |
       |   CPU    |        |   AFU   |
       |          |        |         |
       |          |        |         |
       |          |        |         |
       +----------+        +---------+
       |          |        |         |
       |   CAPP   +--------+   PSL   |
       |          |  PCIe  |         |
       +----------+        +---------+

    The POWER8 chip has a Coherently Attached Processor Proxy (CAPP)
    unit which is part of the PCIe Host Bridge (PHB).  This is managed
    by Linux by calls into OPAL.  Linux doesn't directly program the
    CAPP.

    The FPGA (or coherently attached device) consists of two parts.
    The POWER Service Layer (PSL) and the Accelerator Function Unit
    (AFU). AFU is used to implement specific functionality behind
    the PSL.  The PSL, among other things, provides memory address
    translation services to allow each AFU direct access to userspace
    memory.

    The AFU is the core part of the accelerator (eg. the compression,
    crypto etc function).  The kernel has no knowledge of the function
    of the AFU.  Only userspace interacts directly with the AFU.

    The PSL provides the translation and interrupt services that the
    AFU needs.  This is what the kernel interacts with.  For example,
    if the AFU needs to read a particular virtual address, it sends
    that address to the PSL, the PSL then translates it, fetches the
    data from memory and returns it to the AFU.  If the PSL has a
    translation miss, it interrupts the kernel and the kernel services
    the fault.  The context to which this fault is serviced is based
    on who owns that acceleration function.

AFU Models
==========

    There are two programming models supported by the AFU.  Dedicated
    and AFU directed.  AFU may support one or both models.

    In dedicated model only one MMU context is supported.  In this
    model, only one userspace process can use the accelerator at time.

    In AFU directed model, up to 16K simultaneous contexts can be
    supported.  This means up to 16K simultaneous userspace
    applications may use the accelerator (although specific AFUs may
    support less).  In this mode, the AFU sends a 16 bit context ID
    with each of its requests.  This tells the PSL which context is
    associated with this operation.  If the PSL can't translate a
    request, the ID can also be accessed by the kernel so it can
    determine the associated userspace context to service this
    translation with.

MMIO space
==========

    A portion of the FPGA MMIO space can be directly mapped from the
    AFU to userspace.  Either the whole space can be mapped (master
    context), or just a per context portion (slave context).  The
    hardware is self describing, hence the kernel can determine the
    offset and size of the per context portion.

Interrupts
==========

    AFUs may generate interrupts that are destined for userspace.  These
    are received by the kernel as hardware interrupts and passed onto
    userspace.

    Data storage faults and error interrupts are handled by the kernel
    driver.

Work Element Descriptor (WED)
=============================

    The WED is a 64bit parameter passed to the AFU when a context is
    started.  Its format is up to the AFU hence the kernel has no
    knowledge of what it represents.  Typically it will be a virtual
    address pointer to a work queue where the AFU and userspace can
    share control and status information or work queues.




User API
========

    The driver will create two character devices per AFU under
    /dev/cxl.  One for master and one for slave contexts.

    The master context (eg. /dev/cxl/afu0.0m), has access to all of
    the MMIO space that an AFU provides.  The slave context
    (eg. /dev/cxl/afu0.0m) has access to only the per process MMIO
    space an AFU provides (AFU directed only).

    The following file operations are supported on both slave and
    master devices:

    open

        Opens device and allocates a file descriptor to be used with
        the rest of the API.  This may be opened multiple times,
        depending on how many contexts the AFU supports.

        A dedicated model AFU only has one context and hence only
        allows this device to be opened once.

        A AFU directed model AFU can have many contexts and hence this
        device can be opened by as many contexts as available.

        Note: IRQs also need to be allocated per context, which may
              also limit the number of contexts that can be allocated.
              The POWER8 CAPP supports 2040 IRQs and 3 are used by the
              kernel, so 2037 are left.  If 1 IRQ is needed per
              context, then only 2037 contexts can be allocated.  If 4
              IRQs are needed per context, then only 2037/4 = 509
              contexts can be allocated.

    ioctl

        CAPI_IOCTL_START_WORK:
            Starts the AFU and associates it with the process memory
            context.  Once this ioctl is successfully executed, all
            memory mapped into this process is accessible to this AFU
            context using the same virtual addresses.  No additional
            calls are required to un/map memory.  The AFU context will
            be updated as userspace allocates and frees memory.  This
            ioctl returns once the context is started.

            Takes a pointer to a struct cxl_ioctl_start_work
                    struct cxl_ioctl_start_work {
                            __u64 flags;
                            __u64 wed;
                            __u64 amr;
                            __s16 num_interrupts;
			    __s16 reserved1;
			    __s32 reserved2;
                            __u64 reserved3;
                            __u64 reserved4;
                            __u64 reserved5;
                            __u64 reserved6;
                    };

		flags: Mandatory
                    User specified flags for optional fields in the
                    struct.  The wed is compulsory but all other
                    fields are optional using the
                    CXL_START_WORK_* flags.

                wed: Mandatory
		    64bit argument defined by the AFU.  Typically this
                    is an virtual address pointing to an AFU specific
                    structure describing what work to perform.  Must
                    be specified.

                amr: Optional
                    Authority Mask Register (AMR), same as the powerpc
                    AMR.  If not specified this will be inherited from
                    userspace.

                num_interrupt: Optional
                    Number of userspace interrupts to request.  If not
                    specified the minimum number required will be
                    automatically allocated.  The min and max number
                    can be obtained from sysfs.

                reserved fields: Mandatory
                    For ABI padding and future extensions

        CAPI_IOCTL_GET_INFO:
            Get info on kernel API revision and the context number.
            This info is returned from the kernel as a struct
            cxl_ioctl_get_info:

		    struct cxl_ioctl_get_info {
			    __u64 flags;
			    __u32 api_version_compatible;
			    __u32 api_version;
			    __u16 process_element;
			    __s16 reserved1;
			    __s32 reserved2;
			    __u64 reserved3;
		    };

	        flags: Mandatory
                    To specify which optional fields the kernel has
		    filled out.  All options are mandatory currently.

	        api_version_compatible: Mandatory
		    The lowest version of the api that this kernel
		    supports.

	        api_version: Mandatory
		    The current/highest version of the api that this
		    kernel support.

                process_element: Mandatory
		    Written by the kernel with the context id (AKA
                    process element) it allocates.  Slave contexts may
                    want to communicate this to a master process.
                    Optional (AFUs in dedicated model may not set
                    this)

                reserved fields: Mandatory
                    For ABI padding and future extensions

        CAPI_IOCTL_CHECK_ERROR:
            This checks to see if the AFU has encountered an error and
            if so resets it.  If userspace is accessing MMIO space, it
            may notice an EEH fence (all ones on read) before the kernel,
            hence it needs to inform the kernel of this.

        CAPI_IOCTL_LOAD_AFU_IMAGE:
            Future work: to dynamically load AFU FPGA images.  Without
            this, the AFU is assumed to be pre-loaded on the card.

    mmap

        An AFU may have a MMIO space to facilitate communication with
        the AFU and mmap allows access to this.  The size and contents
        of this area are specific to the particular AFU.  The size can
        be discovered via sysfs.  A read of all ones indicates the AFU
        has encountered an error and CAPI_IOCTL_CHECK_ERROR should be
        used to recover the AFU.

        Master contexts will get all of the MMIO space.  Slave
        contexts will get only the per process space associated with
        its context.

        This mmap call must be done after the IOCTL is started.

        Care should be taken when accessing MMIO space.  Only 32 and
        64bit accesses are supported by POWER8. Also, the AFU will be
        designed with a specific endian, so all MMIO access should
        consider endian (recommend endian(3) variants like: le64toh(),
        be64toh() etc).  These endian issues equally apply to shared
        memory queues the WED may describe.

    read

        Reads an event from the AFU. Will return -EINVAL if the buffer
        is less that 4096 bytes. Blocks if no events are pending. Will
        return -EIO in the case of an unrecoverable error or if the
        card is removed.

	Reads may return multiple events.  Read will return the length
	of the buffer returned and it will be a integral number of
	events up to the buffer size.  The buffer size given must be
	at least 4096 bytes.

        All events will return a struct cxl_event which varies in
        size.

		struct cxl_event {
			struct cxl_event_header header;
			union {
				struct cxl_event_afu_interrupt irq;
				struct cxl_event_data_storage fault;
				struct cxl_event_afu_error afu_err;
			};
		};

	A struct cxl_event_header at the start gives:
		struct cxl_event_header {
			__u16 type;
			__u16 size;
			__u16 process_element;
			__u16 reserved1;
		};

            type: Mandatory
                This gives the type of the interrupt.  This gives how
                the rest event will be structured.  It can be either:
                AFU interrupt, data storage fault or AFU error.

            size: Mandatory
                This is the size of the event.  The start of the next
                buffer can be found at this offset from the start of
                the current buffer.

            process_element: Mandatory
                Context ID of the event.  Currently this will always
                be the current context.  Future work may allow
                interrupts from one context to be routed to another
                (eg. a master contexts handling error interrupts on
                behalf of a slave).

            reserved field: Mandatory
                For future extensions and padding.

        If an AFU interrupt event is received, the full structure received is:
                struct cxl_event_afu_interrupt {
			__u16 flags;
			__u16 irq; /* Raised AFU interrupt number */
			__u32 reserved1;
                };

	    flags: Mandatory
	        These flags indicate which optional fields are present
	        in this struct.  Currently all fields are Mandatory.

            irq: Mandatory
                The IRQ number sent by the AFU.

            reserved field:
                For future extensions and padding.

        If an data storage event is received, the full structure received is:
		struct cxl_event_data_storage {
			__u32 flags;
			__u32 reserved1;
			__u64 addr;
			__u64 dsisr;
			__u64 reserved1;
		};

	    flags: Mandatory
	        These flags indicate which optional fields are present
	        in this struct.  Currently all fields are Mandatory.

	    dsisr: Manditory
	        These fields give information on the type of
	        fault. Copy of the DSISR from PSL hardware when
	        address fault occured.

            address: Mandatory
                Address of the data storage trying to be accessed by
                the AFU.  Valid accesses will handled transparently by
                the kernel but invalid access will generate this
                event.

            reserved fields:
                For future extensions

        If an AFU error event is received, the full structure received is:
		struct cxl_event_afu_error {
			__u16 flags;
			__u16 reserved1;
			__u32 reserved2;
			__u64 err;
		};

	    flags: Mandatory
	        These flags indicate which optional fields are present
	        in this struct.  Currently all fields are Mandatory.

            err:
                Error status from the AFU.  AFU defined.

            reserved fields:
                For future extensions and padding

Sysfs Class
===========

    A cxl sysfs class is added under /sys/class/cxl to facilitate
    enumeration and tuning of the accelerators. Its layout is
    described in Documentation/ABI/testing/sysfs-class-cxl
